from typing_extensions import Self
from collections.abc import Callable
import enum
from typing import overload

import islpy._monkeypatch


class Error(Exception):
    pass

class error(enum.Enum):
    __str__ = enum.Enum.__str__

    __repr__ = enum.Enum.__str__

    none = 0

    abort = 1

    alloc = 2

    unknown = 3

    internal = 4

    invalid = 5

    quota = 6

    unsupported = 7

class stat(enum.Enum):
    __str__ = enum.Enum.__str__

    __repr__ = enum.Enum.__str__

    error = -1

    ok = 0

class dim_type(enum.IntEnum):
    __str__ = enum.Enum.__str__

    __repr__ = enum.Enum.__str__

    cst = 0

    param = 1

    in_ = 2
    out = 3

    set = 3

    div = 4

    all = 5

    __reduce__ = islpy._monkeypatch.dim_type_reduce

class schedule_node_type(enum.Enum):
    __str__ = enum.Enum.__str__

    __repr__ = enum.Enum.__str__

    error = -1

    band = 0

    context = 1

    domain = 2

    expansion = 3

    extension = 4

    filter = 5

    leaf = 6

    guard = 7

    mark = 8

    sequence = 9

    set = 10

class ast_expr_op_type(enum.Enum):
    __str__ = enum.Enum.__str__

    __repr__ = enum.Enum.__str__

    error = -1

    and_then = 1

    or_else = 3

    max = 4

    min = 5

    minus = 6

    add = 7

    sub = 8

    mul = 9

    div = 10

    fdiv_q = 11

    pdiv_q = 12

    pdiv_r = 13

    zdiv_r = 14

    cond = 15

    select = 16

    eq = 17

    le = 18

    lt = 19

    ge = 20

    gt = 21

    call = 22

    access = 23

    member = 24

    address_of = 25

class fold(enum.Enum):
    __str__ = enum.Enum.__str__

    __repr__ = enum.Enum.__str__

    min = 0

    max = 1

    list = 2

class ast_expr_type(enum.Enum):
    __str__ = enum.Enum.__str__

    __repr__ = enum.Enum.__str__

    error = -1

    op = 0

    id = 1

    int = 2

class ast_node_type(enum.Enum):
    __str__ = enum.Enum.__str__

    __repr__ = enum.Enum.__str__

    error = -1

    block = 3

    user = 5

    mark = 4

class ast_loop_type(enum.Enum):
    __str__ = enum.Enum.__str__

    __repr__ = enum.Enum.__str__

    error = -1

    default = 0

    atomic = 1

    unroll = 2

    separate = 3

class format:
    ISL: int = 0

    POLYLIB: int = 1

    POLYLIB_CONSTRAINTS: int = 2

    OMEGA: int = 3

    C: int = 4

    LATEX: int = 5

    EXT_POLYLIB: int = 6

class yaml_style:
    BLOCK: int = 0

    FLOW: int = 1

class bound:
    BERNSTEIN: int = 0

    RANGE: int = 1

class on_error:
    WARN: int = 0

    CONTINUE: int = 1

    ABORT: int = 2

class schedule_algorithm:
    ISL: int = 0

    FEAUTRIER: int = 1

def isl_version() -> str: ...

class CallbackLifetimeHandle:
    pass

class Context:
    def __init__(self) -> None: ...

    def abort(self) -> None: ...

    def resume(self) -> None: ...

    def aborted(self) -> int: ...

    def set_max_operations(self, max_operations: int) -> None: ...

    def get_max_operations(self) -> int: ...

    def reset_operations(self) -> None: ...

    def set_schedule_max_coefficient(self, val: int) -> None: ...

    def get_schedule_max_coefficient(self) -> int: ...

    def set_schedule_max_constant_term(self, val: int) -> None: ...

    def get_schedule_max_constant_term(self) -> int: ...

    def set_schedule_maximize_band_depth(self, val: int) -> None: ...

    def get_schedule_maximize_band_depth(self) -> int: ...

    def set_schedule_maximize_coincidence(self, val: int) -> None: ...

    def get_schedule_maximize_coincidence(self) -> int: ...

    def set_schedule_outer_coincidence(self, val: int) -> None: ...

    def get_schedule_outer_coincidence(self) -> int: ...

    def set_schedule_split_scaled(self, val: int) -> None: ...

    def get_schedule_split_scaled(self) -> int: ...

    def set_schedule_treat_coalescing(self, val: int) -> None: ...

    def get_schedule_treat_coalescing(self) -> int: ...

    def set_schedule_separate_components(self, val: int) -> None: ...

    def get_schedule_separate_components(self) -> int: ...

    def set_schedule_serialize_sccs(self, val: int) -> None: ...

    def get_schedule_serialize_sccs(self) -> int: ...

    def set_schedule_whole_component(self, val: int) -> None: ...

    def get_schedule_whole_component(self) -> int: ...

    def set_schedule_carry_self_first(self, val: int) -> None: ...

    def get_schedule_carry_self_first(self) -> int: ...

    def set_tile_scale_tile_loops(self, val: int) -> None: ...

    def get_tile_scale_tile_loops(self) -> int: ...

    def set_tile_shift_point_loops(self, val: int) -> None: ...

    def get_tile_shift_point_loops(self) -> int: ...

    def set_bound(self, val: int) -> None: ...

    def get_bound(self) -> int: ...

    def set_on_error(self, val: int) -> None: ...

    def get_on_error(self) -> int: ...

    def set_gbr_only_first(self, val: int) -> None: ...

    def get_gbr_only_first(self) -> int: ...

    def set_schedule_algorithm(self, val: int) -> None: ...

    def get_schedule_algorithm(self) -> int: ...

    def set_pip_symmetry(self, val: int) -> None: ...

    def get_pip_symmetry(self) -> int: ...

    def set_coalesce_bounded_wrapping(self, val: int) -> None: ...

    def get_coalesce_bounded_wrapping(self) -> int: ...

    def set_coalesce_preserve_locals(self, val: int) -> None: ...

    def get_coalesce_preserve_locals(self) -> int: ...

    def set_ast_iterator_type(self, val: str) -> None: ...

    def get_ast_iterator_type(self) -> str: ...

    def set_ast_always_print_block(self, val: int) -> None: ...

    def get_ast_always_print_block(self) -> int: ...

    def set_ast_print_outermost_block(self, val: int) -> None: ...

    def get_ast_print_outermost_block(self) -> int: ...

    def set_ast_print_macro_once(self, val: int) -> None: ...

    def get_ast_print_macro_once(self) -> int: ...

    def set_ast_build_atomic_upper_bound(self, val: int) -> None: ...

    def get_ast_build_atomic_upper_bound(self) -> int: ...

    def set_ast_build_prefer_pdiv(self, val: int) -> None: ...

    def get_ast_build_prefer_pdiv(self) -> int: ...

    def set_ast_build_detect_min_max(self, val: int) -> None: ...

    def get_ast_build_detect_min_max(self) -> int: ...

    def set_ast_build_exploit_nested_bounds(self, val: int) -> None: ...

    def get_ast_build_exploit_nested_bounds(self) -> int: ...

    def set_ast_build_group_coscheduled(self, val: int) -> None: ...

    def get_ast_build_group_coscheduled(self) -> int: ...

    def set_ast_build_separation_bounds(self, val: int) -> None: ...

    def get_ast_build_separation_bounds(self) -> int: ...

    def set_ast_build_scale_strides(self, val: int) -> None: ...

    def get_ast_build_scale_strides(self) -> int: ...

    def set_ast_build_allow_else(self, val: int) -> None: ...

    def get_ast_build_allow_else(self) -> int: ...

    def set_ast_build_allow_or(self, val: int) -> None: ...

    def get_ast_build_allow_or(self) -> int: ...

    __reduce__ = islpy._monkeypatch.context_reduce

    __eq__ = islpy._monkeypatch.context_eq

    __ne__ = islpy._monkeypatch.context_ne

class IdList:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_id(el: Id) -> IdList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> IdList: ...

    def copy(self) -> IdList: ...

    def add(self, el: Id) -> IdList: ...

    def insert(self, pos: int, el: Id) -> IdList: ...

    def drop(self, first: int, n: int) -> IdList: ...

    def clear(self) -> IdList: ...

    def swap(self, pos1: int, pos2: int) -> IdList: ...

    def reverse(self) -> IdList: ...

    def concat(self, list2: IdList) -> IdList: ...

    def __len__(self) -> int: ...

    def n_id(self) -> int: ...

    def get_at(self, index: int) -> Id: ...

    def get_id(self, index: int) -> Id: ...

    def set_at(self, index: int, el: Id) -> IdList: ...

    def set_id(self, index: int, el: Id) -> IdList: ...

    def foreach(self, fn: Callable[[Id], None]) -> None: ...

    def every(self, test: Callable[[Id], bool]) -> bool: ...

    def map(self, fn: Callable[[Id], Id]) -> IdList: ...

    def sort(self, cmp: Callable[[Id, Id], int]) -> IdList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> IdList: ...

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class ValList:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_val(el: Val) -> ValList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> ValList: ...

    def copy(self) -> ValList: ...

    def add(self, el: Val | int) -> ValList: ...

    def insert(self, pos: int, el: Val | int) -> ValList: ...

    def drop(self, first: int, n: int) -> ValList: ...

    def clear(self) -> ValList: ...

    def swap(self, pos1: int, pos2: int) -> ValList: ...

    def reverse(self) -> ValList: ...

    def concat(self, list2: ValList) -> ValList: ...

    def __len__(self) -> int: ...

    def n_val(self) -> int: ...

    def get_at(self, index: int) -> Val: ...

    def get_val(self, index: int) -> Val: ...

    def set_at(self, index: int, el: Val | int) -> ValList: ...

    def set_val(self, index: int, el: Val | int) -> ValList: ...

    def foreach(self, fn: Callable[[Val], None]) -> None: ...

    def every(self, test: Callable[[Val], bool]) -> bool: ...

    def map(self, fn: Callable[[Val], Val]) -> ValList: ...

    def sort(self, cmp: Callable[[Val, Val], int]) -> ValList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> ValList: ...

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class BasicSetList:
    def intersect(self) -> BasicSet: ...

    def coefficients(self) -> BasicSetList: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_basic_set(el: BasicSet) -> BasicSetList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> BasicSetList: ...

    def copy(self) -> BasicSetList: ...

    def add(self, el: BasicSet) -> BasicSetList: ...

    def insert(self, pos: int, el: BasicSet) -> BasicSetList: ...

    def drop(self, first: int, n: int) -> BasicSetList: ...

    def clear(self) -> BasicSetList: ...

    def swap(self, pos1: int, pos2: int) -> BasicSetList: ...

    def reverse(self) -> BasicSetList: ...

    def concat(self, list2: BasicSetList) -> BasicSetList: ...

    def __len__(self) -> int: ...

    def n_basic_set(self) -> int: ...

    def get_at(self, index: int) -> BasicSet: ...

    def get_basic_set(self, index: int) -> BasicSet: ...

    def set_at(self, index: int, el: BasicSet) -> BasicSetList: ...

    def set_basic_set(self, index: int, el: BasicSet) -> BasicSetList: ...

    def foreach(self, fn: Callable[[BasicSet], None]) -> None: ...

    def every(self, test: Callable[[BasicSet], bool]) -> bool: ...

    def map(self, fn: Callable[[BasicSet], BasicSet]) -> BasicSetList: ...

    def sort(self, cmp: Callable[[BasicSet, BasicSet], int]) -> BasicSetList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class BasicMapList:
    def intersect(self) -> BasicMap: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_basic_map(el: BasicMap) -> BasicMapList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> BasicMapList: ...

    def copy(self) -> BasicMapList: ...

    def add(self, el: BasicMap) -> BasicMapList: ...

    def insert(self, pos: int, el: BasicMap) -> BasicMapList: ...

    def drop(self, first: int, n: int) -> BasicMapList: ...

    def clear(self) -> BasicMapList: ...

    def swap(self, pos1: int, pos2: int) -> BasicMapList: ...

    def reverse(self) -> BasicMapList: ...

    def concat(self, list2: BasicMapList) -> BasicMapList: ...

    def __len__(self) -> int: ...

    def n_basic_map(self) -> int: ...

    def get_at(self, index: int) -> BasicMap: ...

    def get_basic_map(self, index: int) -> BasicMap: ...

    def set_at(self, index: int, el: BasicMap) -> BasicMapList: ...

    def set_basic_map(self, index: int, el: BasicMap) -> BasicMapList: ...

    def foreach(self, fn: Callable[[BasicMap], None]) -> None: ...

    def every(self, test: Callable[[BasicMap], bool]) -> bool: ...

    def map(self, fn: Callable[[BasicMap], BasicMap]) -> BasicMapList: ...

    def sort(self, cmp: Callable[[BasicMap, BasicMap], int]) -> BasicMapList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class SetList:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def union(self) -> Set: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_set(el: Set | BasicSet) -> SetList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> SetList: ...

    def copy(self) -> SetList: ...

    def add(self, el: Set | BasicSet) -> SetList: ...

    def insert(self, pos: int, el: Set | BasicSet) -> SetList: ...

    def drop(self, first: int, n: int) -> SetList: ...

    def clear(self) -> SetList: ...

    def swap(self, pos1: int, pos2: int) -> SetList: ...

    def reverse(self) -> SetList: ...

    def concat(self, list2: SetList) -> SetList: ...

    def __len__(self) -> int: ...

    def n_set(self) -> int: ...

    def get_at(self, index: int) -> Set: ...

    def get_set(self, index: int) -> Set: ...

    def set_at(self, index: int, el: Set | BasicSet) -> SetList: ...

    def set_set(self, index: int, el: Set | BasicSet) -> SetList: ...

    def foreach(self, fn: Callable[[Set], None]) -> None: ...

    def every(self, test: Callable[[Set], bool]) -> bool: ...

    def map(self, fn: Callable[[Set], Set]) -> SetList: ...

    def sort(self, cmp: Callable[[Set, Set], int]) -> SetList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> SetList: ...

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class MapList:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_map(el: Map | BasicMap) -> MapList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> MapList: ...

    def copy(self) -> MapList: ...

    def add(self, el: Map | BasicMap) -> MapList: ...

    def insert(self, pos: int, el: Map | BasicMap) -> MapList: ...

    def drop(self, first: int, n: int) -> MapList: ...

    def clear(self) -> MapList: ...

    def swap(self, pos1: int, pos2: int) -> MapList: ...

    def reverse(self) -> MapList: ...

    def concat(self, list2: MapList) -> MapList: ...

    def __len__(self) -> int: ...

    def n_map(self) -> int: ...

    def get_at(self, index: int) -> Map: ...

    def get_map(self, index: int) -> Map: ...

    def set_at(self, index: int, el: Map | BasicMap) -> MapList: ...

    def set_map(self, index: int, el: Map | BasicMap) -> MapList: ...

    def foreach(self, fn: Callable[[Map], None]) -> None: ...

    def every(self, test: Callable[[Map], bool]) -> bool: ...

    def map(self, fn: Callable[[Map], Map]) -> MapList: ...

    def sort(self, cmp: Callable[[Map, Map], int]) -> MapList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> MapList: ...

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class UnionSetList:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_union_set(el: UnionSet | BasicSet | Set) -> UnionSetList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> UnionSetList: ...

    def copy(self) -> UnionSetList: ...

    def add(self, el: UnionSet | BasicSet | Set) -> UnionSetList: ...

    def insert(self, pos: int, el: UnionSet | BasicSet | Set) -> UnionSetList: ...

    def drop(self, first: int, n: int) -> UnionSetList: ...

    def clear(self) -> UnionSetList: ...

    def swap(self, pos1: int, pos2: int) -> UnionSetList: ...

    def reverse(self) -> UnionSetList: ...

    def concat(self, list2: UnionSetList) -> UnionSetList: ...

    def __len__(self) -> int: ...

    def n_union_set(self) -> int: ...

    def get_at(self, index: int) -> UnionSet: ...

    def get_union_set(self, index: int) -> UnionSet: ...

    def set_at(self, index: int, el: UnionSet | BasicSet | Set) -> UnionSetList: ...

    def set_union_set(self, index: int, el: UnionSet | BasicSet | Set) -> UnionSetList: ...

    def foreach(self, fn: Callable[[UnionSet], None]) -> None: ...

    def every(self, test: Callable[[UnionSet], bool]) -> bool: ...

    def map(self, fn: Callable[[UnionSet], UnionSet]) -> UnionSetList: ...

    def sort(self, cmp: Callable[[UnionSet, UnionSet], int]) -> UnionSetList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> UnionSetList: ...

    def union(self) -> UnionSet: ...

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class ConstraintList:
    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_constraint(el: Constraint) -> ConstraintList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> ConstraintList: ...

    def copy(self) -> ConstraintList: ...

    def add(self, el: Constraint) -> ConstraintList: ...

    def insert(self, pos: int, el: Constraint) -> ConstraintList: ...

    def drop(self, first: int, n: int) -> ConstraintList: ...

    def clear(self) -> ConstraintList: ...

    def swap(self, pos1: int, pos2: int) -> ConstraintList: ...

    def reverse(self) -> ConstraintList: ...

    def concat(self, list2: ConstraintList) -> ConstraintList: ...

    def __len__(self) -> int: ...

    def n_constraint(self) -> int: ...

    def get_at(self, index: int) -> Constraint: ...

    def get_constraint(self, index: int) -> Constraint: ...

    def set_at(self, index: int, el: Constraint) -> ConstraintList: ...

    def set_constraint(self, index: int, el: Constraint) -> ConstraintList: ...

    def foreach(self, fn: Callable[[Constraint], None]) -> None: ...

    def every(self, test: Callable[[Constraint], bool]) -> bool: ...

    def map(self, fn: Callable[[Constraint], Constraint]) -> ConstraintList: ...

    def sort(self, cmp: Callable[[Constraint, Constraint], int]) -> ConstraintList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class AffList:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_aff(el: Aff) -> AffList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> AffList: ...

    def copy(self) -> AffList: ...

    def add(self, el: Aff) -> AffList: ...

    def insert(self, pos: int, el: Aff) -> AffList: ...

    def drop(self, first: int, n: int) -> AffList: ...

    def clear(self) -> AffList: ...

    def swap(self, pos1: int, pos2: int) -> AffList: ...

    def reverse(self) -> AffList: ...

    def concat(self, list2: AffList) -> AffList: ...

    def __len__(self) -> int: ...

    def n_aff(self) -> int: ...

    def get_at(self, index: int) -> Aff: ...

    def get_aff(self, index: int) -> Aff: ...

    def set_at(self, index: int, el: Aff) -> AffList: ...

    def set_aff(self, index: int, el: Aff) -> AffList: ...

    def foreach(self, fn: Callable[[Aff], None]) -> None: ...

    def every(self, test: Callable[[Aff], bool]) -> bool: ...

    def map(self, fn: Callable[[Aff], Aff]) -> AffList: ...

    def sort(self, cmp: Callable[[Aff, Aff], int]) -> AffList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> AffList: ...

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class PwAffList:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def min(self) -> PwAff: ...

    def max(self) -> PwAff: ...

    def eq_set(self, list2: PwAffList) -> Set: ...

    def ne_set(self, list2: PwAffList) -> Set: ...

    def le_set(self, list2: PwAffList) -> Set: ...

    def lt_set(self, list2: PwAffList) -> Set: ...

    def ge_set(self, list2: PwAffList) -> Set: ...

    def gt_set(self, list2: PwAffList) -> Set: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_pw_aff(el: PwAff | Aff) -> PwAffList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> PwAffList: ...

    def copy(self) -> PwAffList: ...

    def add(self, el: PwAff | Aff) -> PwAffList: ...

    def insert(self, pos: int, el: PwAff | Aff) -> PwAffList: ...

    def drop(self, first: int, n: int) -> PwAffList: ...

    def clear(self) -> PwAffList: ...

    def swap(self, pos1: int, pos2: int) -> PwAffList: ...

    def reverse(self) -> PwAffList: ...

    def concat(self, list2: PwAffList) -> PwAffList: ...

    def __len__(self) -> int: ...

    def n_pw_aff(self) -> int: ...

    def get_at(self, index: int) -> PwAff: ...

    def get_pw_aff(self, index: int) -> PwAff: ...

    def set_at(self, index: int, el: PwAff | Aff) -> PwAffList: ...

    def set_pw_aff(self, index: int, el: PwAff | Aff) -> PwAffList: ...

    def foreach(self, fn: Callable[[PwAff], None]) -> None: ...

    def every(self, test: Callable[[PwAff], bool]) -> bool: ...

    def map(self, fn: Callable[[PwAff], PwAff]) -> PwAffList: ...

    def sort(self, cmp: Callable[[PwAff, PwAff], int]) -> PwAffList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> PwAffList: ...

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class PwMultiAffList:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_pw_multi_aff(el: PwMultiAff | MultiAff) -> PwMultiAffList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> PwMultiAffList: ...

    def copy(self) -> PwMultiAffList: ...

    def add(self, el: PwMultiAff | MultiAff) -> PwMultiAffList: ...

    def insert(self, pos: int, el: PwMultiAff | MultiAff) -> PwMultiAffList: ...

    def drop(self, first: int, n: int) -> PwMultiAffList: ...

    def clear(self) -> PwMultiAffList: ...

    def swap(self, pos1: int, pos2: int) -> PwMultiAffList: ...

    def reverse(self) -> PwMultiAffList: ...

    def concat(self, list2: PwMultiAffList) -> PwMultiAffList: ...

    def __len__(self) -> int: ...

    def n_pw_multi_aff(self) -> int: ...

    def get_at(self, index: int) -> PwMultiAff: ...

    def get_pw_multi_aff(self, index: int) -> PwMultiAff: ...

    def set_at(self, index: int, el: PwMultiAff | MultiAff) -> PwMultiAffList: ...

    def set_pw_multi_aff(self, index: int, el: PwMultiAff | MultiAff) -> PwMultiAffList: ...

    def foreach(self, fn: Callable[[PwMultiAff], None]) -> None: ...

    def every(self, test: Callable[[PwMultiAff], bool]) -> bool: ...

    def map(self, fn: Callable[[PwMultiAff], PwMultiAff]) -> PwMultiAffList: ...

    def sort(self, cmp: Callable[[PwMultiAff, PwMultiAff], int]) -> PwMultiAffList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> PwMultiAffList: ...

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class AstExprList:
    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_ast_expr(el: AstExpr) -> AstExprList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> AstExprList: ...

    def copy(self) -> AstExprList: ...

    def add(self, el: AstExpr) -> AstExprList: ...

    def insert(self, pos: int, el: AstExpr) -> AstExprList: ...

    def drop(self, first: int, n: int) -> AstExprList: ...

    def clear(self) -> AstExprList: ...

    def swap(self, pos1: int, pos2: int) -> AstExprList: ...

    def reverse(self) -> AstExprList: ...

    def concat(self, list2: AstExprList) -> AstExprList: ...

    def __len__(self) -> int: ...

    def n_ast_expr(self) -> int: ...

    def get_at(self, index: int) -> AstExpr: ...

    def get_ast_expr(self, index: int) -> AstExpr: ...

    def set_at(self, index: int, el: AstExpr) -> AstExprList: ...

    def set_ast_expr(self, index: int, el: AstExpr) -> AstExprList: ...

    def foreach(self, fn: Callable[[AstExpr], None]) -> None: ...

    def every(self, test: Callable[[AstExpr], bool]) -> bool: ...

    def map(self, fn: Callable[[AstExpr], AstExpr]) -> AstExprList: ...

    def sort(self, cmp: Callable[[AstExpr, AstExpr], int]) -> AstExprList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class AstNodeList:
    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_ast_node(el: AstNode) -> AstNodeList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> AstNodeList: ...

    def copy(self) -> AstNodeList: ...

    def add(self, el: AstNode) -> AstNodeList: ...

    def insert(self, pos: int, el: AstNode) -> AstNodeList: ...

    def drop(self, first: int, n: int) -> AstNodeList: ...

    def clear(self) -> AstNodeList: ...

    def swap(self, pos1: int, pos2: int) -> AstNodeList: ...

    def reverse(self) -> AstNodeList: ...

    def concat(self, list2: AstNodeList) -> AstNodeList: ...

    def __len__(self) -> int: ...

    def n_ast_node(self) -> int: ...

    def get_at(self, index: int) -> AstNode: ...

    def get_ast_node(self, index: int) -> AstNode: ...

    def set_at(self, index: int, el: AstNode) -> AstNodeList: ...

    def set_ast_node(self, index: int, el: AstNode) -> AstNodeList: ...

    def foreach(self, fn: Callable[[AstNode], None]) -> None: ...

    def every(self, test: Callable[[AstNode], bool]) -> bool: ...

    def map(self, fn: Callable[[AstNode], AstNode]) -> AstNodeList: ...

    def sort(self, cmp: Callable[[AstNode, AstNode], int]) -> AstNodeList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class QPolynomialList:
    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_qpolynomial(el: QPolynomial) -> QPolynomialList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> QPolynomialList: ...

    def copy(self) -> QPolynomialList: ...

    def add(self, el: QPolynomial) -> QPolynomialList: ...

    def insert(self, pos: int, el: QPolynomial) -> QPolynomialList: ...

    def drop(self, first: int, n: int) -> QPolynomialList: ...

    def clear(self) -> QPolynomialList: ...

    def swap(self, pos1: int, pos2: int) -> QPolynomialList: ...

    def reverse(self) -> QPolynomialList: ...

    def concat(self, list2: QPolynomialList) -> QPolynomialList: ...

    def __len__(self) -> int: ...

    def n_qpolynomial(self) -> int: ...

    def get_at(self, index: int) -> QPolynomial: ...

    def get_qpolynomial(self, index: int) -> QPolynomial: ...

    def set_at(self, index: int, el: QPolynomial) -> QPolynomialList: ...

    def set_qpolynomial(self, index: int, el: QPolynomial) -> QPolynomialList: ...

    def foreach(self, fn: Callable[[QPolynomial], None]) -> None: ...

    def every(self, test: Callable[[QPolynomial], bool]) -> bool: ...

    def map(self, fn: Callable[[QPolynomial], QPolynomial]) -> QPolynomialList: ...

    def sort(self, cmp: Callable[[QPolynomial, QPolynomial], int]) -> QPolynomialList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class PwQPolynomialList:
    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_pw_qpolynomial(el: PwQPolynomial) -> PwQPolynomialList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> PwQPolynomialList: ...

    def copy(self) -> PwQPolynomialList: ...

    def add(self, el: PwQPolynomial) -> PwQPolynomialList: ...

    def insert(self, pos: int, el: PwQPolynomial) -> PwQPolynomialList: ...

    def drop(self, first: int, n: int) -> PwQPolynomialList: ...

    def clear(self) -> PwQPolynomialList: ...

    def swap(self, pos1: int, pos2: int) -> PwQPolynomialList: ...

    def reverse(self) -> PwQPolynomialList: ...

    def concat(self, list2: PwQPolynomialList) -> PwQPolynomialList: ...

    def __len__(self) -> int: ...

    def n_pw_qpolynomial(self) -> int: ...

    def get_at(self, index: int) -> PwQPolynomial: ...

    def get_pw_qpolynomial(self, index: int) -> PwQPolynomial: ...

    def set_at(self, index: int, el: PwQPolynomial) -> PwQPolynomialList: ...

    def set_pw_qpolynomial(self, index: int, el: PwQPolynomial) -> PwQPolynomialList: ...

    def foreach(self, fn: Callable[[PwQPolynomial], None]) -> None: ...

    def every(self, test: Callable[[PwQPolynomial], bool]) -> bool: ...

    def map(self, fn: Callable[[PwQPolynomial], PwQPolynomial]) -> PwQPolynomialList: ...

    def sort(self, cmp: Callable[[PwQPolynomial, PwQPolynomial], int]) -> PwQPolynomialList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class PwQPolynomialFoldList:
    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_pw_qpolynomial_fold(el: PwQPolynomialFold) -> PwQPolynomialFoldList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> PwQPolynomialFoldList: ...

    def copy(self) -> PwQPolynomialFoldList: ...

    def add(self, el: PwQPolynomialFold) -> PwQPolynomialFoldList: ...

    def insert(self, pos: int, el: PwQPolynomialFold) -> PwQPolynomialFoldList: ...

    def drop(self, first: int, n: int) -> PwQPolynomialFoldList: ...

    def clear(self) -> PwQPolynomialFoldList: ...

    def swap(self, pos1: int, pos2: int) -> PwQPolynomialFoldList: ...

    def reverse(self) -> PwQPolynomialFoldList: ...

    def concat(self, list2: PwQPolynomialFoldList) -> PwQPolynomialFoldList: ...

    def __len__(self) -> int: ...

    def n_pw_qpolynomial_fold(self) -> int: ...

    def get_at(self, index: int) -> PwQPolynomialFold: ...

    def get_pw_qpolynomial_fold(self, index: int) -> PwQPolynomialFold: ...

    def set_at(self, index: int, el: PwQPolynomialFold) -> PwQPolynomialFoldList: ...

    def set_pw_qpolynomial_fold(self, index: int, el: PwQPolynomialFold) -> PwQPolynomialFoldList: ...

    def foreach(self, fn: Callable[[PwQPolynomialFold], None]) -> None: ...

    def every(self, test: Callable[[PwQPolynomialFold], bool]) -> bool: ...

    def map(self, fn: Callable[[PwQPolynomialFold], PwQPolynomialFold]) -> PwQPolynomialFoldList: ...

    def sort(self, cmp: Callable[[PwQPolynomialFold, PwQPolynomialFold], int]) -> PwQPolynomialFoldList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class UnionPwAffList:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_union_pw_aff(el: UnionPwAff | Aff | PwAff) -> UnionPwAffList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> UnionPwAffList: ...

    def copy(self) -> UnionPwAffList: ...

    def add(self, el: UnionPwAff | Aff | PwAff) -> UnionPwAffList: ...

    def insert(self, pos: int, el: UnionPwAff | Aff | PwAff) -> UnionPwAffList: ...

    def drop(self, first: int, n: int) -> UnionPwAffList: ...

    def clear(self) -> UnionPwAffList: ...

    def swap(self, pos1: int, pos2: int) -> UnionPwAffList: ...

    def reverse(self) -> UnionPwAffList: ...

    def concat(self, list2: UnionPwAffList) -> UnionPwAffList: ...

    def __len__(self) -> int: ...

    def n_union_pw_aff(self) -> int: ...

    def get_at(self, index: int) -> UnionPwAff: ...

    def get_union_pw_aff(self, index: int) -> UnionPwAff: ...

    def set_at(self, index: int, el: UnionPwAff | Aff | PwAff) -> UnionPwAffList: ...

    def set_union_pw_aff(self, index: int, el: UnionPwAff | Aff | PwAff) -> UnionPwAffList: ...

    def foreach(self, fn: Callable[[UnionPwAff], None]) -> None: ...

    def every(self, test: Callable[[UnionPwAff], bool]) -> bool: ...

    def map(self, fn: Callable[[UnionPwAff], UnionPwAff]) -> UnionPwAffList: ...

    def sort(self, cmp: Callable[[UnionPwAff, UnionPwAff], int]) -> UnionPwAffList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> UnionPwAffList: ...

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class UnionPwMultiAffList:
    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_union_pw_multi_aff(el: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAffList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> UnionPwMultiAffList: ...

    def copy(self) -> UnionPwMultiAffList: ...

    def add(self, el: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAffList: ...

    def insert(self, pos: int, el: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAffList: ...

    def drop(self, first: int, n: int) -> UnionPwMultiAffList: ...

    def clear(self) -> UnionPwMultiAffList: ...

    def swap(self, pos1: int, pos2: int) -> UnionPwMultiAffList: ...

    def reverse(self) -> UnionPwMultiAffList: ...

    def concat(self, list2: UnionPwMultiAffList) -> UnionPwMultiAffList: ...

    def __len__(self) -> int: ...

    def n_union_pw_multi_aff(self) -> int: ...

    def get_at(self, index: int) -> UnionPwMultiAff: ...

    def get_union_pw_multi_aff(self, index: int) -> UnionPwMultiAff: ...

    def set_at(self, index: int, el: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAffList: ...

    def set_union_pw_multi_aff(self, index: int, el: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAffList: ...

    def foreach(self, fn: Callable[[UnionPwMultiAff], None]) -> None: ...

    def every(self, test: Callable[[UnionPwMultiAff], bool]) -> bool: ...

    def map(self, fn: Callable[[UnionPwMultiAff], UnionPwMultiAff]) -> UnionPwMultiAffList: ...

    def sort(self, cmp: Callable[[UnionPwMultiAff, UnionPwMultiAff], int]) -> UnionPwMultiAffList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class UnionMapList:
    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_union_map(el: UnionMap | BasicMap | Map) -> UnionMapList: ...

    @staticmethod
    def alloc(ctx: Context, n: int) -> UnionMapList: ...

    def copy(self) -> UnionMapList: ...

    def add(self, el: UnionMap | BasicMap | Map) -> UnionMapList: ...

    def insert(self, pos: int, el: UnionMap | BasicMap | Map) -> UnionMapList: ...

    def drop(self, first: int, n: int) -> UnionMapList: ...

    def clear(self) -> UnionMapList: ...

    def swap(self, pos1: int, pos2: int) -> UnionMapList: ...

    def reverse(self) -> UnionMapList: ...

    def concat(self, list2: UnionMapList) -> UnionMapList: ...

    def __len__(self) -> int: ...

    def n_union_map(self) -> int: ...

    def get_at(self, index: int) -> UnionMap: ...

    def get_union_map(self, index: int) -> UnionMap: ...

    def set_at(self, index: int, el: UnionMap | BasicMap | Map) -> UnionMapList: ...

    def set_union_map(self, index: int, el: UnionMap | BasicMap | Map) -> UnionMapList: ...

    def foreach(self, fn: Callable[[UnionMap], None]) -> None: ...

    def every(self, test: Callable[[UnionMap], bool]) -> bool: ...

    def map(self, fn: Callable[[UnionMap], UnionMap]) -> UnionMapList: ...

    def sort(self, cmp: Callable[[UnionMap, UnionMap], int]) -> UnionMapList: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class IdToAstExpr:
    pass

class Printer:
    def print_id_list(self, list: IdList) -> Self: ...

    def print_id(self, id: Id) -> Self: ...

    def print_multi_id(self, mi: MultiId) -> Self: ...

    def print_space(self, space: Space) -> Self: ...

    def print_basic_set(self, bset: BasicSet) -> Self: ...

    def print_set(self, map: Set | BasicSet) -> Self: ...

    def print_basic_map(self, bmap: BasicMap) -> Self: ...

    def print_map(self, map: Map | BasicMap) -> Self: ...

    def print_basic_map_list(self, list: BasicMapList) -> Self: ...

    def print_map_list(self, list: MapList) -> Self: ...

    def print_basic_set_list(self, list: BasicSetList) -> Self: ...

    def print_set_list(self, list: SetList) -> Self: ...

    def print_local_space(self, ls: LocalSpace | Space) -> Self: ...

    def print_aff(self, aff: Aff) -> Self: ...

    def print_pw_aff(self, pwaff: PwAff | Aff) -> Self: ...

    def print_multi_aff(self, maff: MultiAff) -> Self: ...

    def print_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> Self: ...

    def print_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> Self: ...

    def print_multi_pw_aff(self, mpa: MultiPwAff) -> Self: ...

    def print_union_pw_aff(self, upa: UnionPwAff | Aff | PwAff) -> Self: ...

    def print_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> Self: ...

    def print_aff_list(self, list: AffList) -> Self: ...

    def print_pw_aff_list(self, list: PwAffList) -> Self: ...

    def print_pw_multi_aff_list(self, list: PwMultiAffList) -> Self: ...

    def print_union_pw_aff_list(self, list: UnionPwAffList) -> Self: ...

    def print_union_pw_multi_aff_list(self, list: UnionPwMultiAffList) -> Self: ...

    def print_qpolynomial(self, qp: QPolynomial) -> Self: ...

    def print_pw_qpolynomial(self, pwqp: PwQPolynomial) -> Self: ...

    def print_qpolynomial_fold(self, fold: QPolynomialFold) -> Self: ...

    def print_pw_qpolynomial_fold(self, pwf: PwQPolynomialFold) -> Self: ...

    def print_union_pw_qpolynomial(self, upwqp: UnionPwQPolynomial) -> Self: ...

    def print_union_pw_qpolynomial_fold(self, upwf: UnionPwQPolynomialFold) -> Self: ...

    def print_qpolynomial_list(self, list: QPolynomialList) -> Self: ...

    def print_pw_qpolynomial_list(self, list: PwQPolynomialList) -> Self: ...

    def print_pw_qpolynomial_fold_list(self, list: PwQPolynomialFoldList) -> Self: ...

    def print_union_map(self, umap: UnionMap | BasicMap | Map) -> Self: ...

    def print_union_map_list(self, list: UnionMapList) -> Self: ...

    def print_union_set(self, uset: UnionSet | BasicSet | Set) -> Self: ...

    def print_union_set_list(self, list: UnionSetList) -> Self: ...

    @staticmethod
    def to_str(ctx: Context) -> Printer: ...

    def get_ctx(self) -> Context: ...

    def get_str(self) -> str: ...

    def set_indent(self, indent: int) -> Self: ...

    def indent(self, indent: int) -> Self: ...

    def set_output_format(self, output_format: int) -> Self: ...

    def get_output_format(self) -> int: ...

    def set_yaml_style(self, yaml_style: int) -> Self: ...

    def get_yaml_style(self) -> int: ...

    def set_indent_prefix(self, prefix: str) -> Self: ...

    def set_prefix(self, prefix: str) -> Self: ...

    def set_suffix(self, suffix: str) -> Self: ...

    def set_isl_int_width(self, width: int) -> Self: ...

    def has_note(self, id: Id) -> bool: ...

    def get_note(self, id: Id) -> Id: ...

    def set_note(self, id: Id, note: Id) -> Self: ...

    def start_line(self) -> Self: ...

    def end_line(self) -> Self: ...

    def print_double(self, d: int) -> Self: ...

    def print_int(self, i: int) -> Self: ...

    def print_str(self, s: str) -> Self: ...

    def yaml_start_mapping(self) -> Self: ...

    def yaml_end_mapping(self) -> Self: ...

    def yaml_start_sequence(self) -> Self: ...

    def yaml_end_sequence(self) -> Self: ...

    def yaml_next(self) -> Self: ...

    def flush(self) -> Self: ...

    def print_point(self, pnt: Point) -> Self: ...

    def print_constraint_list(self, list: ConstraintList) -> Self: ...

    def print_constraint(self, c: Constraint) -> Self: ...

    def print_val(self, v: Val | int) -> Self: ...

    def print_multi_val(self, mv: MultiVal) -> Self: ...

    def print_val_list(self, list: ValList) -> Self: ...

    def print_vec(self, vec: Vec) -> Self: ...

    def print_schedule_constraints(self, sc: ScheduleConstraints) -> Self: ...

    def print_schedule(self, schedule: Schedule) -> Self: ...

    def print_schedule_node(self, node: ScheduleNode) -> Self: ...

    def print_union_access_info(self, access: UnionAccessInfo) -> Self: ...

    def print_union_flow(self, flow: UnionFlow) -> Self: ...

    def print_ast_expr(self, expr: AstExpr) -> Self: ...

    def print_ast_node(self, node: AstNode) -> Self: ...

    def ast_op_type_set_print_name(self, type: ast_expr_op_type, name: str) -> Self: ...

    def print_ast_expr_list(self, list: AstExprList) -> Self: ...

    def print_ast_node_list(self, list: AstNodeList) -> Self: ...

class Val:
    @overload
    def __init__(self, i: int, context: Context | None = None) -> None: ...

    @overload
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    @staticmethod
    def zero(ctx: Context) -> Val: ...

    @staticmethod
    def one(ctx: Context) -> Val: ...

    @staticmethod
    def negone(ctx: Context) -> Val: ...

    @staticmethod
    def nan(ctx: Context) -> Val: ...

    @staticmethod
    def infty(ctx: Context) -> Val: ...

    @staticmethod
    def neginfty(ctx: Context) -> Val: ...

    @staticmethod
    def int_from_si(ctx: Context, i: int) -> Val: ...

    @staticmethod
    def int_from_ui(ctx: Context, u: int) -> Val: ...

    def copy(self) -> Val: ...

    def get_ctx(self) -> Context: ...

    def __hash__(self) -> int: ...

    def get_num_si(self) -> int: ...

    def get_den_val(self) -> Val: ...

    def get_d(self) -> int: ...

    def n_abs_num_chunks(self, size: int) -> int: ...

    def set_si(self, i: int) -> Val: ...

    def abs(self) -> Val: ...

    def neg(self) -> Val: ...

    def inv(self) -> Val: ...

    def floor(self) -> Val: ...

    def ceil(self) -> Val: ...

    def trunc(self) -> Val: ...

    def two_exp(self) -> Val: ...

    def pow2(self) -> Val: ...

    def min(self, v2: Val | int) -> Val: ...

    def max(self, v2: Val | int) -> Val: ...

    def add(self, v2: Val | int) -> Val: ...

    def sub(self, v2: Val | int) -> Val: ...

    def mul(self, v2: Val | int) -> Val: ...

    def div(self, v2: Val | int) -> Val: ...

    def mod(self, v2: Val | int) -> Val: ...

    def gcd(self, v2: Val | int) -> Val: ...

    def gcdext(self, v2: Val | int) -> tuple[Val, Val, Val]: ...

    def sgn(self) -> int: ...

    def is_zero(self) -> bool: ...

    def is_one(self) -> bool: ...

    def is_negone(self) -> bool: ...

    def is_nonneg(self) -> bool: ...

    def is_nonpos(self) -> bool: ...

    def is_pos(self) -> bool: ...

    def is_neg(self) -> bool: ...

    def is_int(self) -> bool: ...

    def is_rat(self) -> bool: ...

    def is_nan(self) -> bool: ...

    def is_infty(self) -> bool: ...

    def is_neginfty(self) -> bool: ...

    def cmp_si(self, i: int) -> int: ...

    def lt(self, v2: Val | int) -> bool: ...

    def le(self, v2: Val | int) -> bool: ...

    def gt(self, v2: Val | int) -> bool: ...

    def ge(self, v2: Val | int) -> bool: ...

    def eq(self, v2: Val | int) -> bool: ...

    def ne(self, v2: Val | int) -> bool: ...

    def abs_eq(self, v2: Val | int) -> bool: ...

    def is_divisible_by(self, v2: Val | int) -> bool: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> Val: ...

    def dump(self) -> None: ...

    def to_str(self) -> str: ...

    def to_list(self) -> ValList: ...

    __add__ = add

    __radd__ = add

    __sub__ = sub

    __rsub__ = islpy._monkeypatch.val_rsub

    __mul__ = mul

    __rmul__ = mul

    __neg__ = neg

    __mod__ = mod

    __bool__ = islpy._monkeypatch.val_bool

    __nonzero__ = islpy._monkeypatch.val_bool

    __lt__ = lt

    __gt__ = gt

    __le__ = le

    __ge__ = ge

    __eq__ = eq

    __ne__ = ne

    __repr__ = islpy._monkeypatch.generic_repr

    __str__ = islpy._monkeypatch.generic_str

    to_python = islpy._monkeypatch.val_to_python

    __reduce__ = islpy._monkeypatch.generic_reduce

class MultiVal:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_domain_space(self) -> Space: ...

    def get_list(self) -> ValList: ...

    @staticmethod
    def from_val_list(space: Space, list: ValList) -> MultiVal: ...

    def copy(self) -> MultiVal: ...

    def plain_is_equal(self, multi2: MultiVal) -> bool: ...

    def reset_user(self) -> MultiVal: ...

    def __len__(self) -> int: ...

    def get_at(self, pos: int) -> Val: ...

    def get_val(self, pos: int) -> Val: ...

    def set_at(self, pos: int, el: Val | int) -> MultiVal: ...

    def set_val(self, pos: int, el: Val | int) -> MultiVal: ...

    def range_splice(self, pos: int, multi2: MultiVal) -> MultiVal: ...

    def flatten_range(self) -> MultiVal: ...

    def flat_range_product(self, multi2: MultiVal) -> MultiVal: ...

    def range_product(self, multi2: MultiVal) -> MultiVal: ...

    def factor_range(self) -> MultiVal: ...

    def range_is_wrapping(self) -> bool: ...

    def range_factor_domain(self) -> MultiVal: ...

    def range_factor_range(self) -> MultiVal: ...

    def align_params(self, model: Space) -> MultiVal: ...

    def from_range(self) -> MultiVal: ...

    def scale_val(self, v: Val | int) -> MultiVal: ...

    def scale_down_val(self, v: Val | int) -> MultiVal: ...

    def scale_multi_val(self, mv: MultiVal) -> MultiVal: ...

    def scale_down_multi_val(self, mv: MultiVal) -> MultiVal: ...

    def mod_multi_val(self, mv: MultiVal) -> MultiVal: ...

    def add(self, multi2: MultiVal) -> MultiVal: ...

    def sub(self, multi2: MultiVal) -> MultiVal: ...

    def neg(self) -> MultiVal: ...

    def min(self, multi2: MultiVal) -> MultiVal: ...

    def max(self, multi2: MultiVal) -> MultiVal: ...

    @staticmethod
    def zero(space: Space) -> MultiVal: ...

    def involves_nan(self) -> bool: ...

    def dim(self, type: dim_type) -> int: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> MultiVal: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def insert_dims(self, type: dim_type, first: int, n: int) -> MultiVal: ...

    def add_dims(self, type: dim_type, n: int) -> MultiVal: ...

    def project_domain_on_params(self) -> MultiVal: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def find_dim_by_id(self, type: dim_type, id: Id) -> int: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> MultiVal: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> MultiVal: ...

    def get_tuple_name(self, type: dim_type) -> str: ...

    def has_range_tuple_id(self) -> bool: ...

    def has_tuple_id(self, type: dim_type) -> bool: ...

    def get_range_tuple_id(self) -> Id: ...

    def get_tuple_id(self, type: dim_type) -> Id: ...

    def set_tuple_name(self, type: dim_type, s: str) -> MultiVal: ...

    def set_range_tuple_id(self, id: Id) -> MultiVal: ...

    def set_tuple_id(self, type: dim_type, id: Id) -> MultiVal: ...

    def reset_range_tuple_id(self) -> MultiVal: ...

    def reset_tuple_id(self, type: dim_type) -> MultiVal: ...

    def product(self, multi2: MultiVal) -> MultiVal: ...

    def splice(self, in_pos: int, out_pos: int, multi2: MultiVal) -> MultiVal: ...

    def is_zero(self) -> bool: ...

    def add_val(self, v: Val | int) -> MultiVal: ...

    def mod_val(self, v: Val | int) -> MultiVal: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> MultiVal: ...

    def dump(self) -> None: ...

    def to_str(self) -> str: ...

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class Vec:
    @staticmethod
    def alloc(ctx: Context, size: int) -> Vec: ...

    @staticmethod
    def zero(ctx: Context, size: int) -> Vec: ...

    def copy(self) -> Vec: ...

    def get_ctx(self) -> Context: ...

    def __len__(self) -> int: ...

    def get_element_val(self, pos: int) -> Val: ...

    def set_element_val(self, pos: int, v: Val | int) -> Vec: ...

    def is_equal(self, vec2: Vec) -> bool: ...

    def cmp_element(self, vec2: Vec, pos: int) -> int: ...

    def dump(self) -> None: ...

    def ceil(self) -> Vec: ...

    def normalize(self) -> Vec: ...

    def set_val(self, v: Val | int) -> Vec: ...

    def clr(self) -> Vec: ...

    def neg(self) -> Vec: ...

    def add(self, vec2: Vec) -> Vec: ...

    def extend(self, size: int) -> Vec: ...

    def zero_extend(self, size: int) -> Vec: ...

    def concat(self, vec2: Vec) -> Vec: ...

    def sort(self) -> Vec: ...

    def drop_els(self, pos: int, n: int) -> Vec: ...

    def add_els(self, n: int) -> Vec: ...

    def insert_els(self, pos: int, n: int) -> Vec: ...

    def insert_zero_els(self, pos: int, n: int) -> Vec: ...

    def move_els(self, dst_col: int, src_col: int, n: int) -> Vec: ...

    def mat_product(self, mat: Mat) -> Vec: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class Mat:
    def get_ctx(self) -> Context: ...

    @staticmethod
    def alloc(ctx: Context, n_row: int, n_col: int) -> Mat: ...

    def extend(self, n_row: int, n_col: int) -> Mat: ...

    @staticmethod
    def identity(ctx: Context, n_row: int) -> Mat: ...

    def copy(self) -> Mat: ...

    def rows(self) -> int: ...

    def cols(self) -> int: ...

    def get_element_val(self, row: int, col: int) -> Val: ...

    def set_element_val(self, row: int, col: int, v: Val | int) -> Mat: ...

    def swap_cols(self, i: int, j: int) -> Mat: ...

    def swap_rows(self, i: int, j: int) -> Mat: ...

    def vec_product(self, vec: Vec) -> Vec: ...

    def vec_inverse_product(self, vec: Vec) -> Vec: ...

    def aff_direct_sum(self, right: Mat) -> Mat: ...

    def diagonal(self, mat2: Mat) -> Mat: ...

    def left_hermite(self, neg: int) -> tuple[Mat, Mat, Mat]: ...

    def lin_to_aff(self) -> Mat: ...

    def inverse_product(self, right: Mat) -> Mat: ...

    def product(self, right: Mat) -> Mat: ...

    def transpose(self) -> Mat: ...

    def right_inverse(self) -> Mat: ...

    def right_kernel(self) -> Mat: ...

    def normalize(self) -> Mat: ...

    def normalize_row(self, row: int) -> Mat: ...

    def drop_cols(self, col: int, n: int) -> Mat: ...

    def drop_rows(self, row: int, n: int) -> Mat: ...

    def insert_cols(self, col: int, n: int) -> Mat: ...

    def insert_rows(self, row: int, n: int) -> Mat: ...

    def move_cols(self, dst_col: int, src_col: int, n: int) -> Mat: ...

    def add_rows(self, n: int) -> Mat: ...

    def insert_zero_cols(self, first: int, n: int) -> Mat: ...

    def add_zero_cols(self, n: int) -> Mat: ...

    def insert_zero_rows(self, row: int, n: int) -> Mat: ...

    def add_zero_rows(self, n: int) -> Mat: ...

    def col_add(self, dst_col: int, src_col: int) -> None: ...

    def unimodular_complete(self, row: int) -> Mat: ...

    def row_basis(self) -> Mat: ...

    def row_basis_extension(self, mat2: Mat) -> Mat: ...

    @staticmethod
    def from_row_vec(vec: Vec) -> Mat: ...

    def concat(self, bot: Mat) -> Mat: ...

    def vec_concat(self, bot: Vec) -> Mat: ...

    def is_equal(self, mat2: Mat) -> bool: ...

    def has_linearly_independent_rows(self, mat2: Mat) -> bool: ...

    def rank(self) -> int: ...

    def initial_non_zero_cols(self) -> int: ...

    def dump(self) -> None: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

class FixedBox:
    pass

class Aff:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def to_pw_aff(self) -> PwAff: ...

    @staticmethod
    def zero_on_domain_space(space: Space) -> Aff: ...

    @staticmethod
    def zero_on_domain(ls: LocalSpace | Space) -> Aff: ...

    @staticmethod
    def val_on_domain_space(space: Space, val: Val | int) -> Aff: ...

    @staticmethod
    def val_on_domain(ls: LocalSpace | Space, val: Val | int) -> Aff: ...

    @staticmethod
    def var_on_domain(ls: LocalSpace | Space, type: dim_type, pos: int) -> Aff: ...

    @staticmethod
    def nan_on_domain_space(space: Space) -> Aff: ...

    @staticmethod
    def nan_on_domain(ls: LocalSpace | Space) -> Aff: ...

    @staticmethod
    def param_on_domain_space_id(space: Space, id: Id) -> Aff: ...

    def copy(self) -> Aff: ...

    def get_ctx(self) -> Context: ...

    def __hash__(self) -> int: ...

    def involves_locals(self) -> bool: ...

    def dim(self, type: dim_type) -> int: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def get_domain_space(self) -> Space: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_domain_local_space(self) -> LocalSpace: ...

    def get_local_space(self) -> LocalSpace: ...

    def get_dim_name(self, type: dim_type, pos: int) -> str | None: ...

    def get_constant_val(self) -> Val: ...

    def get_coefficient_val(self, type: dim_type, pos: int) -> Val: ...

    def coefficient_sgn(self, type: dim_type, pos: int) -> int: ...

    def get_denominator_val(self) -> Val: ...

    def set_constant_val(self, v: Val | int) -> Aff: ...

    def set_coefficient_val(self, type: dim_type, pos: int, v: Val | int) -> Aff: ...

    def add_constant_val(self, v: Val | int) -> Aff: ...

    def add_constant_num_si(self, v: int) -> Aff: ...

    def add_coefficient_val(self, type: dim_type, pos: int, v: Val | int) -> Aff: ...

    def is_cst(self) -> bool: ...

    def set_tuple_id(self, type: dim_type, id: Id) -> Aff: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> Aff: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> Aff: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    @overload
    def plain_is_equal(self, aff2: Aff) -> bool: ...

    @overload
    def plain_is_equal(self, pwaff2: PwAff | Aff) -> bool: ...

    @overload
    def plain_is_equal(self, upa2: UnionPwAff | Aff | PwAff) -> bool: ...

    def plain_is_zero(self) -> bool: ...

    def is_nan(self) -> bool: ...

    def get_div(self, pos: int) -> Aff: ...

    def from_range(self) -> Aff: ...

    def neg(self) -> Aff: ...

    def ceil(self) -> Aff: ...

    def floor(self) -> Aff: ...

    def mod_val(self, mod: Val | int) -> Aff: ...

    @overload
    def mul(self, aff2: Aff) -> Aff: ...

    @overload
    def mul(self, pwaff2: PwAff | Aff) -> PwAff: ...

    @overload
    def div(self, aff2: Aff) -> Aff: ...

    @overload
    def div(self, pa2: PwAff | Aff) -> PwAff: ...

    @overload
    def add(self, aff2: Aff) -> Aff: ...

    @overload
    def add(self, pwaff2: PwAff | Aff) -> PwAff: ...

    @overload
    def add(self, upa2: UnionPwAff | Aff | PwAff) -> UnionPwAff: ...

    @overload
    def sub(self, aff2: Aff) -> Aff: ...

    @overload
    def sub(self, pwaff2: PwAff | Aff) -> PwAff: ...

    @overload
    def sub(self, upa2: UnionPwAff | Aff | PwAff) -> UnionPwAff: ...

    def scale_val(self, v: Val | int) -> Aff: ...

    def scale_down_val(self, v: Val | int) -> Aff: ...

    def domain_reverse(self) -> Aff: ...

    def insert_dims(self, type: dim_type, first: int, n: int) -> Aff: ...

    def add_dims(self, type: dim_type, n: int) -> Aff: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> Aff: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> Aff: ...

    def project_domain_on_params(self) -> Aff: ...

    def unbind_params_insert_domain(self, domain: MultiId) -> Aff: ...

    def align_params(self, model: Space) -> Aff: ...

    @overload
    def gist(self, context: Set | BasicSet) -> Aff: ...

    @overload
    def gist(self, context: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def gist_params(self, context: Set | BasicSet) -> Aff: ...

    def eval(self, pnt: Point) -> Val: ...

    def pullback_aff(self, aff2: Aff) -> Aff: ...

    def pullback_multi_aff(self, ma: MultiAff) -> Aff: ...

    def zero_basic_set(self) -> BasicSet: ...

    def neg_basic_set(self) -> BasicSet: ...

    def eq_basic_set(self, aff2: Aff) -> BasicSet: ...

    @overload
    def eq_set(self, aff2: Aff) -> Set: ...

    @overload
    def eq_set(self, pwaff2: PwAff | Aff) -> Set: ...

    @overload
    def ne_set(self, aff2: Aff) -> Set: ...

    @overload
    def ne_set(self, pwaff2: PwAff | Aff) -> Set: ...

    def le_basic_set(self, aff2: Aff) -> BasicSet: ...

    @overload
    def le_set(self, aff2: Aff) -> Set: ...

    @overload
    def le_set(self, pwaff2: PwAff | Aff) -> Set: ...

    def lt_basic_set(self, aff2: Aff) -> BasicSet: ...

    @overload
    def lt_set(self, aff2: Aff) -> Set: ...

    @overload
    def lt_set(self, pwaff2: PwAff | Aff) -> Set: ...

    def ge_basic_set(self, aff2: Aff) -> BasicSet: ...

    @overload
    def ge_set(self, aff2: Aff) -> Set: ...

    @overload
    def ge_set(self, pwaff2: PwAff | Aff) -> Set: ...

    def gt_basic_set(self, aff2: Aff) -> BasicSet: ...

    @overload
    def gt_set(self, aff2: Aff) -> Set: ...

    @overload
    def gt_set(self, pwaff2: PwAff | Aff) -> Set: ...

    def bind_id(self, id: Id) -> BasicSet: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> Aff: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    def to_list(self) -> AffList: ...

    def has_dim_id(self, type: dim_type, pos: int) -> bool: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def is_empty(self) -> bool: ...

    def involves_nan(self) -> bool: ...

    def plain_cmp(self, pa2: PwAff | Aff) -> int: ...

    def is_equal(self, pa2: PwAff | Aff) -> bool: ...

    def union_min(self, pwaff2: PwAff | Aff) -> PwAff: ...

    def union_max(self, pwaff2: PwAff | Aff) -> PwAff: ...

    @overload
    def union_add(self, pwaff2: PwAff | Aff) -> PwAff: ...

    @overload
    def union_add(self, upa2: UnionPwAff | Aff | PwAff) -> UnionPwAff: ...

    def involves_param_id(self, id: Id) -> bool: ...

    def insert_domain(self, domain: Space) -> PwAff: ...

    def drop_unused_params(self) -> PwAff: ...

    def has_tuple_id(self, type: dim_type) -> bool: ...

    def get_tuple_id(self, type: dim_type) -> Id: ...

    def reset_tuple_id(self, type: dim_type) -> PwAff: ...

    def reset_user(self) -> PwAff: ...

    def params(self) -> Set: ...

    def domain(self) -> Set: ...

    def min(self, pwaff2: PwAff | Aff) -> PwAff: ...

    def max(self, pwaff2: PwAff | Aff) -> PwAff: ...

    def tdiv_q(self, pa2: PwAff | Aff) -> PwAff: ...

    def tdiv_r(self, pa2: PwAff | Aff) -> PwAff: ...

    def intersect_params(self, set: Set | BasicSet) -> PwAff: ...

    @overload
    def intersect_domain(self, set: Set | BasicSet) -> PwAff: ...

    @overload
    def intersect_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    @overload
    def intersect_domain_wrapped_domain(self, set: Set | BasicSet) -> PwAff: ...

    @overload
    def intersect_domain_wrapped_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    @overload
    def intersect_domain_wrapped_range(self, set: Set | BasicSet) -> PwAff: ...

    @overload
    def intersect_domain_wrapped_range(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    @overload
    def subtract_domain(self, set: Set | BasicSet) -> PwAff: ...

    @overload
    def subtract_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def cond(self, pwaff_true: PwAff | Aff, pwaff_false: PwAff | Aff) -> PwAff: ...

    def coalesce(self) -> PwAff: ...

    def pullback_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> PwAff: ...

    def pullback_multi_pw_aff(self, mpa: MultiPwAff) -> PwAff: ...

    def n_piece(self) -> int: ...

    def foreach_piece(self, fn: Callable[[Set, Aff], None]) -> None: ...

    def every_piece(self, test: Callable[[Set, Aff], bool]) -> bool: ...

    def isa_aff(self) -> bool: ...

    def as_aff(self) -> Aff: ...

    def as_map(self) -> Map: ...

    def pos_set(self) -> Set: ...

    def nonneg_set(self) -> Set: ...

    def zero_set(self) -> Set: ...

    def non_zero_set(self) -> Set: ...

    def eq_map(self, pa2: PwAff | Aff) -> Map: ...

    def le_map(self, pa2: PwAff | Aff) -> Map: ...

    def lt_map(self, pa2: PwAff | Aff) -> Map: ...

    def ge_map(self, pa2: PwAff | Aff) -> Map: ...

    def gt_map(self, pa2: PwAff | Aff) -> Map: ...

    def bind_domain(self, tuple: MultiId) -> PwAff: ...

    def bind_domain_wrapped_domain(self, tuple: MultiId) -> PwAff: ...

    def to_union_pw_aff(self) -> UnionPwAff: ...

    def min_val(self) -> Val: ...

    def max_val(self) -> Val: ...

    def get_pw_aff_list(self) -> PwAffList: ...

    def add_pw_aff(self, pa: PwAff | Aff) -> UnionPwAff: ...

    def n_pw_aff(self) -> int: ...

    def foreach_pw_aff(self, fn: Callable[[PwAff], None]) -> None: ...

    def every_pw_aff(self, test: Callable[[PwAff], bool]) -> bool: ...

    def extract_pw_aff(self, space: Space) -> PwAff: ...

    def pullback_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwAff: ...

    def intersect_domain_space(self, space: Space) -> UnionPwAff: ...

    def intersect_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def subtract_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def subtract_domain_space(self, space: Space) -> UnionPwAff: ...

    def zero_union_set(self) -> UnionSet: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    get_pieces = islpy._monkeypatch.pwaff_get_pieces

    __add__ = islpy._monkeypatch.expr_like_add

    __radd__ = islpy._monkeypatch.expr_like_add

    __sub__ = islpy._monkeypatch.expr_like_sub

    __rsub__ = islpy._monkeypatch.expr_like_rsub

    __mul__ = islpy._monkeypatch.expr_like_mul

    __rmul__ = islpy._monkeypatch.expr_like_mul

    __neg__ = neg

    __mod__ = mod_val

    __floordiv__ = islpy._monkeypatch.expr_like_floordiv

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

    set_coefficients = islpy._monkeypatch.obj_set_coefficients

    set_coefficients_by_name = islpy._monkeypatch.obj_set_coefficients_by_name

    get_coefficients_by_name = islpy._monkeypatch.obj_get_coefficients_by_name

class PwAff:
    @overload
    def __init__(self, arg: Aff, /) -> None: ...

    @overload
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    def __hash__(self) -> int: ...

    def get_domain_space(self) -> Space: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    @staticmethod
    def from_aff(aff: Aff) -> PwAff: ...

    @staticmethod
    def empty(space: Space) -> PwAff: ...

    @staticmethod
    def alloc(set: Set | BasicSet, aff: Aff) -> PwAff: ...

    @staticmethod
    def zero_on_domain(ls: LocalSpace | Space) -> PwAff: ...

    @staticmethod
    def var_on_domain(ls: LocalSpace | Space, type: dim_type, pos: int) -> PwAff: ...

    @staticmethod
    def nan_on_domain_space(space: Space) -> PwAff: ...

    @staticmethod
    def nan_on_domain(ls: LocalSpace | Space) -> PwAff: ...

    @staticmethod
    def val_on_domain(domain: Set | BasicSet, v: Val | int) -> PwAff: ...

    @staticmethod
    def param_on_domain_id(domain: Set | BasicSet, id: Id) -> PwAff: ...

    def get_dim_name(self, type: dim_type, pos: int) -> str | None: ...

    def has_dim_id(self, type: dim_type, pos: int) -> bool: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> PwAff: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def is_empty(self) -> bool: ...

    def involves_nan(self) -> bool: ...

    def plain_cmp(self, pa2: PwAff | Aff) -> int: ...

    @overload
    def plain_is_equal(self, pwaff2: PwAff | Aff) -> bool: ...

    @overload
    def plain_is_equal(self, upa2: UnionPwAff | Aff | PwAff) -> bool: ...

    def is_equal(self, pa2: PwAff | Aff) -> bool: ...

    def union_min(self, pwaff2: PwAff | Aff) -> PwAff: ...

    def union_max(self, pwaff2: PwAff | Aff) -> PwAff: ...

    @overload
    def union_add(self, pwaff2: PwAff | Aff) -> PwAff: ...

    @overload
    def union_add(self, upa2: UnionPwAff | Aff | PwAff) -> UnionPwAff: ...

    def copy(self) -> PwAff: ...

    def dim(self, type: dim_type) -> int: ...

    def involves_param_id(self, id: Id) -> bool: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def is_cst(self) -> bool: ...

    def insert_domain(self, domain: Space) -> PwAff: ...

    def project_domain_on_params(self) -> PwAff: ...

    def align_params(self, model: Space) -> PwAff: ...

    def drop_unused_params(self) -> PwAff: ...

    def has_tuple_id(self, type: dim_type) -> bool: ...

    def get_tuple_id(self, type: dim_type) -> Id: ...

    def set_tuple_id(self, type: dim_type, id: Id) -> PwAff: ...

    def reset_tuple_id(self, type: dim_type) -> PwAff: ...

    def reset_user(self) -> PwAff: ...

    def params(self) -> Set: ...

    def domain(self) -> Set: ...

    def from_range(self) -> PwAff: ...

    def min(self, pwaff2: PwAff | Aff) -> PwAff: ...

    def max(self, pwaff2: PwAff | Aff) -> PwAff: ...

    def mul(self, pwaff2: PwAff | Aff) -> PwAff: ...

    def div(self, pa2: PwAff | Aff) -> PwAff: ...

    @overload
    def add(self, pwaff2: PwAff | Aff) -> PwAff: ...

    @overload
    def add(self, upa2: UnionPwAff | Aff | PwAff) -> UnionPwAff: ...

    @overload
    def sub(self, pwaff2: PwAff | Aff) -> PwAff: ...

    @overload
    def sub(self, upa2: UnionPwAff | Aff | PwAff) -> UnionPwAff: ...

    def neg(self) -> PwAff: ...

    def ceil(self) -> PwAff: ...

    def floor(self) -> PwAff: ...

    def mod_val(self, mod: Val | int) -> PwAff: ...

    def tdiv_q(self, pa2: PwAff | Aff) -> PwAff: ...

    def tdiv_r(self, pa2: PwAff | Aff) -> PwAff: ...

    def intersect_params(self, set: Set | BasicSet) -> PwAff: ...

    @overload
    def intersect_domain(self, set: Set | BasicSet) -> PwAff: ...

    @overload
    def intersect_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    @overload
    def intersect_domain_wrapped_domain(self, set: Set | BasicSet) -> PwAff: ...

    @overload
    def intersect_domain_wrapped_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    @overload
    def intersect_domain_wrapped_range(self, set: Set | BasicSet) -> PwAff: ...

    @overload
    def intersect_domain_wrapped_range(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    @overload
    def subtract_domain(self, set: Set | BasicSet) -> PwAff: ...

    @overload
    def subtract_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def cond(self, pwaff_true: PwAff | Aff, pwaff_false: PwAff | Aff) -> PwAff: ...

    def add_constant_val(self, v: Val | int) -> PwAff: ...

    def scale_val(self, v: Val | int) -> PwAff: ...

    def scale_down_val(self, f: Val | int) -> PwAff: ...

    def domain_reverse(self) -> PwAff: ...

    def insert_dims(self, type: dim_type, first: int, n: int) -> PwAff: ...

    def add_dims(self, type: dim_type, n: int) -> PwAff: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> PwAff: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> PwAff: ...

    def coalesce(self) -> PwAff: ...

    @overload
    def gist(self, context: Set | BasicSet) -> PwAff: ...

    @overload
    def gist(self, context: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def gist_params(self, context: Set | BasicSet) -> PwAff: ...

    def eval(self, pnt: Point) -> Val: ...

    def pullback_multi_aff(self, ma: MultiAff) -> PwAff: ...

    def pullback_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> PwAff: ...

    def pullback_multi_pw_aff(self, mpa: MultiPwAff) -> PwAff: ...

    def n_piece(self) -> int: ...

    def foreach_piece(self, fn: Callable[[Set, Aff], None]) -> None: ...

    def every_piece(self, test: Callable[[Set, Aff], bool]) -> bool: ...

    def isa_aff(self) -> bool: ...

    def as_aff(self) -> Aff: ...

    def as_map(self) -> Map: ...

    def pos_set(self) -> Set: ...

    def nonneg_set(self) -> Set: ...

    def zero_set(self) -> Set: ...

    def non_zero_set(self) -> Set: ...

    def eq_set(self, pwaff2: PwAff | Aff) -> Set: ...

    def ne_set(self, pwaff2: PwAff | Aff) -> Set: ...

    def le_set(self, pwaff2: PwAff | Aff) -> Set: ...

    def lt_set(self, pwaff2: PwAff | Aff) -> Set: ...

    def ge_set(self, pwaff2: PwAff | Aff) -> Set: ...

    def gt_set(self, pwaff2: PwAff | Aff) -> Set: ...

    def eq_map(self, pa2: PwAff | Aff) -> Map: ...

    def le_map(self, pa2: PwAff | Aff) -> Map: ...

    def lt_map(self, pa2: PwAff | Aff) -> Map: ...

    def ge_map(self, pa2: PwAff | Aff) -> Map: ...

    def gt_map(self, pa2: PwAff | Aff) -> Map: ...

    def bind_domain(self, tuple: MultiId) -> PwAff: ...

    def bind_domain_wrapped_domain(self, tuple: MultiId) -> PwAff: ...

    def bind_id(self, id: Id) -> Set: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> PwAff: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    def to_union_pw_aff(self) -> UnionPwAff: ...

    def to_list(self) -> PwAffList: ...

    def min_val(self) -> Val: ...

    def max_val(self) -> Val: ...

    def get_pw_aff_list(self) -> PwAffList: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> UnionPwAff: ...

    def add_pw_aff(self, pa: PwAff | Aff) -> UnionPwAff: ...

    def n_pw_aff(self) -> int: ...

    def foreach_pw_aff(self, fn: Callable[[PwAff], None]) -> None: ...

    def every_pw_aff(self, test: Callable[[PwAff], bool]) -> bool: ...

    def extract_pw_aff(self, space: Space) -> PwAff: ...

    def pullback_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwAff: ...

    def intersect_domain_space(self, space: Space) -> UnionPwAff: ...

    def intersect_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def subtract_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def subtract_domain_space(self, space: Space) -> UnionPwAff: ...

    def zero_union_set(self) -> UnionSet: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    get_pieces = islpy._monkeypatch.pwaff_get_pieces

    get_aggregate_domain = islpy._monkeypatch.pw_get_aggregate_domain

    __add__ = islpy._monkeypatch.expr_like_add

    __radd__ = islpy._monkeypatch.expr_like_add

    __sub__ = islpy._monkeypatch.expr_like_sub

    __rsub__ = islpy._monkeypatch.expr_like_rsub

    __mul__ = islpy._monkeypatch.expr_like_mul

    __rmul__ = islpy._monkeypatch.expr_like_mul

    __neg__ = neg

    __mod__ = mod_val

    __floordiv__ = islpy._monkeypatch.expr_like_floordiv

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class UnionPwAff:
    @overload
    def __init__(self, arg: PwAff, /) -> None: ...

    @overload
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    @staticmethod
    def param_on_domain_id(domain: UnionSet | BasicSet | Set, id: Id) -> UnionPwAff: ...

    def copy(self) -> UnionPwAff: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_pw_aff_list(self) -> PwAffList: ...

    def dim(self, type: dim_type) -> int: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> UnionPwAff: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> UnionPwAff: ...

    def reset_user(self) -> UnionPwAff: ...

    @staticmethod
    def empty_ctx(ctx: Context) -> UnionPwAff: ...

    @staticmethod
    def empty_space(space: Space) -> UnionPwAff: ...

    @staticmethod
    def empty(space: Space) -> UnionPwAff: ...

    @staticmethod
    def from_aff(aff: Aff) -> UnionPwAff: ...

    @staticmethod
    def from_pw_aff(pa: PwAff | Aff) -> UnionPwAff: ...

    @staticmethod
    def val_on_domain(domain: UnionSet | BasicSet | Set, v: Val | int) -> UnionPwAff: ...

    @staticmethod
    def aff_on_domain(domain: UnionSet | BasicSet | Set, aff: Aff) -> UnionPwAff: ...

    @staticmethod
    def pw_aff_on_domain(domain: UnionSet | BasicSet | Set, pa: PwAff | Aff) -> UnionPwAff: ...

    def add_pw_aff(self, pa: PwAff | Aff) -> UnionPwAff: ...

    def n_pw_aff(self) -> int: ...

    def foreach_pw_aff(self, fn: Callable[[PwAff], None]) -> None: ...

    def every_pw_aff(self, test: Callable[[PwAff], bool]) -> bool: ...

    def extract_pw_aff(self, space: Space) -> PwAff: ...

    def involves_nan(self) -> bool: ...

    def plain_is_equal(self, upa2: UnionPwAff | Aff | PwAff) -> bool: ...

    def domain(self) -> UnionSet: ...

    def neg(self) -> UnionPwAff: ...

    def add(self, upa2: UnionPwAff | Aff | PwAff) -> UnionPwAff: ...

    def union_add(self, upa2: UnionPwAff | Aff | PwAff) -> UnionPwAff: ...

    def sub(self, upa2: UnionPwAff | Aff | PwAff) -> UnionPwAff: ...

    def coalesce(self) -> UnionPwAff: ...

    def gist(self, context: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def gist_params(self, context: Set | BasicSet) -> UnionPwAff: ...

    def pullback_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwAff: ...

    def floor(self) -> UnionPwAff: ...

    def scale_val(self, v: Val | int) -> UnionPwAff: ...

    def scale_down_val(self, v: Val | int) -> UnionPwAff: ...

    def mod_val(self, f: Val | int) -> UnionPwAff: ...

    def align_params(self, model: Space) -> UnionPwAff: ...

    def drop_unused_params(self) -> UnionPwAff: ...

    def intersect_params(self, set: Set | BasicSet) -> UnionPwAff: ...

    def intersect_domain_space(self, space: Space) -> UnionPwAff: ...

    def intersect_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def intersect_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def intersect_domain_wrapped_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def intersect_domain_wrapped_range(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def subtract_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def subtract_domain_space(self, space: Space) -> UnionPwAff: ...

    def subtract_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwAff: ...

    def zero_union_set(self) -> UnionSet: ...

    def bind_id(self, id: Id) -> UnionSet: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> UnionPwAff: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    def to_list(self) -> UnionPwAffList: ...

    def min_val(self) -> Val: ...

    def max_val(self) -> Val: ...

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class MultiId:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_domain_space(self) -> Space: ...

    def get_list(self) -> IdList: ...

    @staticmethod
    def from_id_list(space: Space, list: IdList) -> MultiId: ...

    def copy(self) -> MultiId: ...

    def plain_is_equal(self, multi2: MultiId) -> bool: ...

    def reset_user(self) -> MultiId: ...

    def __len__(self) -> int: ...

    def get_at(self, pos: int) -> Id: ...

    def get_id(self, pos: int) -> Id: ...

    def set_at(self, pos: int, el: Id) -> MultiId: ...

    def set_id(self, pos: int, el: Id) -> MultiId: ...

    def range_splice(self, pos: int, multi2: MultiId) -> MultiId: ...

    def flatten_range(self) -> MultiId: ...

    def flat_range_product(self, multi2: MultiId) -> MultiId: ...

    def range_product(self, multi2: MultiId) -> MultiId: ...

    def factor_range(self) -> MultiId: ...

    def range_is_wrapping(self) -> bool: ...

    def range_factor_domain(self) -> MultiId: ...

    def range_factor_range(self) -> MultiId: ...

    def align_params(self, model: Space) -> MultiId: ...

    def from_range(self) -> MultiId: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> MultiId: ...

    def dump(self) -> None: ...

    def to_str(self) -> str: ...

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class MultiAff:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def as_set(self) -> Set: ...

    def as_map(self) -> Map: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_domain_space(self) -> Space: ...

    def get_list(self) -> AffList: ...

    @staticmethod
    def from_aff_list(space: Space, list: AffList) -> MultiAff: ...

    def copy(self) -> MultiAff: ...

    @overload
    def plain_is_equal(self, multi2: MultiAff) -> bool: ...

    @overload
    def plain_is_equal(self, pma2: PwMultiAff | MultiAff) -> bool: ...

    @overload
    def plain_is_equal(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> bool: ...

    def reset_user(self) -> MultiAff: ...

    def __len__(self) -> int: ...

    def get_at(self, pos: int) -> Aff: ...

    def get_aff(self, pos: int) -> Aff: ...

    def set_at(self, pos: int, el: Aff) -> MultiAff: ...

    def set_aff(self, pos: int, el: Aff) -> MultiAff: ...

    def range_splice(self, pos: int, multi2: MultiAff) -> MultiAff: ...

    def flatten_range(self) -> MultiAff: ...

    @overload
    def flat_range_product(self, multi2: MultiAff) -> MultiAff: ...

    @overload
    def flat_range_product(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    @overload
    def flat_range_product(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    @overload
    def range_product(self, multi2: MultiAff) -> MultiAff: ...

    @overload
    def range_product(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    @overload
    def range_product(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def factor_range(self) -> MultiAff: ...

    def range_is_wrapping(self) -> bool: ...

    def range_factor_domain(self) -> MultiAff: ...

    def range_factor_range(self) -> MultiAff: ...

    def align_params(self, model: Space) -> MultiAff: ...

    def from_range(self) -> MultiAff: ...

    def identity_multi_aff(self) -> MultiAff: ...

    @staticmethod
    def identity(space: Space) -> MultiAff: ...

    @staticmethod
    def identity_on_domain_space(space: Space) -> MultiAff: ...

    def plain_cmp(self, multi2: MultiAff) -> int: ...

    def scale_val(self, v: Val | int) -> MultiAff: ...

    def scale_down_val(self, v: Val | int) -> MultiAff: ...

    def scale_multi_val(self, mv: MultiVal) -> MultiAff: ...

    def scale_down_multi_val(self, mv: MultiVal) -> MultiAff: ...

    def mod_multi_val(self, mv: MultiVal) -> MultiAff: ...

    @overload
    def add(self, multi2: MultiAff) -> MultiAff: ...

    @overload
    def add(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    @overload
    def add(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    @overload
    def sub(self, multi2: MultiAff) -> MultiAff: ...

    @overload
    def sub(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    @overload
    def sub(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def neg(self) -> MultiAff: ...

    def add_constant_val(self, v: Val | int) -> MultiAff: ...

    def add_constant_multi_val(self, mv: MultiVal) -> MultiAff: ...

    @staticmethod
    def zero(space: Space) -> MultiAff: ...

    def involves_nan(self) -> bool: ...

    def dim(self, type: dim_type) -> int: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> MultiAff: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def insert_dims(self, type: dim_type, first: int, n: int) -> MultiAff: ...

    def add_dims(self, type: dim_type, n: int) -> MultiAff: ...

    def project_domain_on_params(self) -> MultiAff: ...

    def insert_domain(self, domain: Space) -> MultiAff: ...

    def involves_locals(self) -> bool: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def find_dim_by_id(self, type: dim_type, id: Id) -> int: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> MultiAff: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> MultiAff: ...

    def get_tuple_name(self, type: dim_type) -> str: ...

    def has_range_tuple_id(self) -> bool: ...

    def has_tuple_id(self, type: dim_type) -> bool: ...

    def get_range_tuple_id(self) -> Id: ...

    def get_tuple_id(self, type: dim_type) -> Id: ...

    def set_tuple_name(self, type: dim_type, s: str) -> MultiAff: ...

    def set_range_tuple_id(self, id: Id) -> MultiAff: ...

    def set_tuple_id(self, type: dim_type, id: Id) -> MultiAff: ...

    def reset_range_tuple_id(self) -> MultiAff: ...

    def reset_tuple_id(self, type: dim_type) -> MultiAff: ...

    @overload
    def product(self, multi2: MultiAff) -> MultiAff: ...

    @overload
    def product(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    def splice(self, in_pos: int, out_pos: int, multi2: MultiAff) -> MultiAff: ...

    def bind_domain(self, tuple: MultiId) -> MultiAff: ...

    def bind_domain_wrapped_domain(self, tuple: MultiId) -> MultiAff: ...

    def unbind_params_insert_domain(self, domain: MultiId) -> MultiAff: ...

    def domain_reverse(self) -> MultiAff: ...

    @staticmethod
    def from_aff(aff: Aff) -> MultiAff: ...

    @staticmethod
    def domain_map(space: Space) -> MultiAff: ...

    @staticmethod
    def range_map(space: Space) -> MultiAff: ...

    @staticmethod
    def project_out_map(space: Space, type: dim_type, first: int, n: int) -> MultiAff: ...

    @staticmethod
    def multi_val_on_domain_space(space: Space, mv: MultiVal) -> MultiAff: ...

    @staticmethod
    def multi_val_on_space(space: Space, mv: MultiVal) -> MultiAff: ...

    def get_constant_multi_val(self) -> MultiVal: ...

    def floor(self) -> MultiAff: ...

    def gist_params(self, context: Set | BasicSet) -> MultiAff: ...

    @overload
    def gist(self, context: Set | BasicSet) -> MultiAff: ...

    @overload
    def gist(self, context: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def lift(self) -> tuple[MultiAff, LocalSpace]: ...

    def pullback_multi_aff(self, ma2: MultiAff) -> MultiAff: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> MultiAff: ...

    def lex_lt_set(self, ma2: MultiAff) -> Set: ...

    def lex_le_set(self, ma2: MultiAff) -> Set: ...

    def lex_gt_set(self, ma2: MultiAff) -> Set: ...

    def lex_ge_set(self, ma2: MultiAff) -> Set: ...

    def bind(self, tuple: MultiId) -> BasicSet: ...

    def to_str(self) -> str: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> MultiAff: ...

    def dump(self) -> None: ...

    def to_pw_multi_aff(self) -> PwMultiAff: ...

    def flatten_domain(self) -> MultiAff: ...

    def to_multi_pw_aff(self) -> MultiPwAff: ...

    def to_multi_union_pw_aff(self) -> MultiUnionPwAff: ...

    def involves_param_id(self, id: Id) -> bool: ...

    def get_pw_aff(self, pos: int) -> PwAff: ...

    def set_pw_aff(self, pos: int, pa: PwAff | Aff) -> PwMultiAff: ...

    def has_tuple_name(self, type: dim_type) -> bool: ...

    def domain(self) -> Set: ...

    def get_dim_name(self, type: dim_type, pos: int) -> str | None: ...

    def is_equal(self, pma2: PwMultiAff | MultiAff) -> bool: ...

    def fix_si(self, type: dim_type, pos: int, value: int) -> PwMultiAff: ...

    @overload
    def union_add(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    @overload
    def union_add(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def union_lexmin(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    def union_lexmax(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    def intersect_params(self, set: Set | BasicSet) -> PwMultiAff: ...

    @overload
    def intersect_domain(self, set: Set | BasicSet) -> PwMultiAff: ...

    @overload
    def intersect_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    @overload
    def intersect_domain_wrapped_domain(self, set: Set | BasicSet) -> PwMultiAff: ...

    @overload
    def intersect_domain_wrapped_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    @overload
    def intersect_domain_wrapped_range(self, set: Set | BasicSet) -> PwMultiAff: ...

    @overload
    def intersect_domain_wrapped_range(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    @overload
    def subtract_domain(self, set: Set | BasicSet) -> PwMultiAff: ...

    @overload
    def subtract_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def drop_unused_params(self) -> PwMultiAff: ...

    def coalesce(self) -> PwMultiAff: ...

    def pullback_pw_multi_aff(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    def preimage_domain_wrapped_domain_pw_multi_aff(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    def n_piece(self) -> int: ...

    def foreach_piece(self, fn: Callable[[Set, MultiAff], None]) -> None: ...

    def every_piece(self, test: Callable[[Set, MultiAff], bool]) -> bool: ...

    def isa_multi_aff(self) -> bool: ...

    def as_multi_aff(self) -> MultiAff: ...

    def to_union_pw_multi_aff(self) -> UnionPwMultiAff: ...

    def to_list(self) -> PwMultiAffList: ...

    def min_multi_val(self) -> MultiVal: ...

    def max_multi_val(self) -> MultiVal: ...

    def get_union_pw_aff(self, pos: int) -> UnionPwAff: ...

    def add_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> UnionPwMultiAff: ...

    def get_pw_multi_aff_list(self) -> PwMultiAffList: ...

    def pullback_union_pw_multi_aff(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def apply_union_pw_multi_aff(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def preimage_domain_wrapped_domain_union_pw_multi_aff(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def n_pw_multi_aff(self) -> int: ...

    def foreach_pw_multi_aff(self, fn: Callable[[PwMultiAff], None]) -> None: ...

    def every_pw_multi_aff(self, test: Callable[[PwMultiAff], bool]) -> bool: ...

    def extract_pw_multi_aff(self, space: Space) -> PwMultiAff: ...

    def isa_pw_multi_aff(self) -> bool: ...

    def as_pw_multi_aff(self) -> PwMultiAff: ...

    def plain_is_empty(self) -> bool: ...

    def intersect_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def intersect_domain_space(self, space: Space) -> UnionPwMultiAff: ...

    def subtract_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def subtract_domain_space(self, space: Space) -> UnionPwMultiAff: ...

    def as_union_map(self) -> UnionMap: ...

    def as_multi_union_pw_aff(self) -> MultiUnionPwAff: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class PwMultiAff:
    @overload
    def __init__(self, arg: MultiAff, /) -> None: ...

    @overload
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    @staticmethod
    def zero(space: Space) -> PwMultiAff: ...

    @staticmethod
    def identity_on_domain_space(space: Space) -> PwMultiAff: ...

    @staticmethod
    def identity(space: Space) -> PwMultiAff: ...

    @staticmethod
    def domain_map(space: Space) -> PwMultiAff: ...

    @staticmethod
    def range_map(space: Space) -> PwMultiAff: ...

    @staticmethod
    def project_out_map(space: Space, type: dim_type, first: int, n: int) -> PwMultiAff: ...

    @staticmethod
    def from_multi_aff(ma: MultiAff) -> PwMultiAff: ...

    @staticmethod
    def from_pw_aff(pa: PwAff | Aff) -> PwMultiAff: ...

    @staticmethod
    def alloc(set: Set | BasicSet, maff: MultiAff) -> PwMultiAff: ...

    def copy(self) -> PwMultiAff: ...

    def dim(self, type: dim_type) -> int: ...

    def involves_locals(self) -> bool: ...

    def involves_param_id(self, id: Id) -> bool: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def get_at(self, pos: int) -> PwAff: ...

    def get_pw_aff(self, pos: int) -> PwAff: ...

    def set_pw_aff(self, pos: int, pa: PwAff | Aff) -> PwMultiAff: ...

    def get_ctx(self) -> Context: ...

    def get_domain_space(self) -> Space: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def has_tuple_name(self, type: dim_type) -> bool: ...

    def get_tuple_name(self, type: dim_type) -> str: ...

    def get_range_tuple_id(self) -> Id: ...

    def get_tuple_id(self, type: dim_type) -> Id: ...

    def has_range_tuple_id(self) -> bool: ...

    def has_tuple_id(self, type: dim_type) -> bool: ...

    def set_tuple_id(self, type: dim_type, id: Id) -> PwMultiAff: ...

    def set_range_tuple_id(self, id: Id) -> PwMultiAff: ...

    def reset_tuple_id(self, type: dim_type) -> PwMultiAff: ...

    def reset_user(self) -> PwMultiAff: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> PwMultiAff: ...

    def domain(self) -> Set: ...

    @staticmethod
    def empty(space: Space) -> PwMultiAff: ...

    @staticmethod
    def from_domain(set: Set | BasicSet) -> PwMultiAff: ...

    @staticmethod
    def multi_val_on_domain(domain: Set | BasicSet, mv: MultiVal) -> PwMultiAff: ...

    def get_dim_name(self, type: dim_type, pos: int) -> str | None: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> PwMultiAff: ...

    def involves_nan(self) -> bool: ...

    @overload
    def plain_is_equal(self, pma2: PwMultiAff | MultiAff) -> bool: ...

    @overload
    def plain_is_equal(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> bool: ...

    def is_equal(self, pma2: PwMultiAff | MultiAff) -> bool: ...

    def fix_si(self, type: dim_type, pos: int, value: int) -> PwMultiAff: ...

    @overload
    def union_add(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    @overload
    def union_add(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def domain_reverse(self) -> PwMultiAff: ...

    def neg(self) -> PwMultiAff: ...

    @overload
    def add(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    @overload
    def add(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    @overload
    def sub(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    @overload
    def sub(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def add_constant_val(self, v: Val | int) -> PwMultiAff: ...

    def add_constant_multi_val(self, mv: MultiVal) -> PwMultiAff: ...

    def scale_val(self, v: Val | int) -> PwMultiAff: ...

    def scale_down_val(self, v: Val | int) -> PwMultiAff: ...

    def scale_multi_val(self, mv: MultiVal) -> PwMultiAff: ...

    def scale_down_multi_val(self, mv: MultiVal) -> PwMultiAff: ...

    def union_lexmin(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    def union_lexmax(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    @overload
    def range_product(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    @overload
    def range_product(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    @overload
    def flat_range_product(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    @overload
    def flat_range_product(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def product(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    def range_factor_domain(self) -> PwMultiAff: ...

    def range_factor_range(self) -> PwMultiAff: ...

    def intersect_params(self, set: Set | BasicSet) -> PwMultiAff: ...

    @overload
    def intersect_domain(self, set: Set | BasicSet) -> PwMultiAff: ...

    @overload
    def intersect_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    @overload
    def intersect_domain_wrapped_domain(self, set: Set | BasicSet) -> PwMultiAff: ...

    @overload
    def intersect_domain_wrapped_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    @overload
    def intersect_domain_wrapped_range(self, set: Set | BasicSet) -> PwMultiAff: ...

    @overload
    def intersect_domain_wrapped_range(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    @overload
    def subtract_domain(self, set: Set | BasicSet) -> PwMultiAff: ...

    @overload
    def subtract_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def insert_domain(self, domain: Space) -> PwMultiAff: ...

    def project_domain_on_params(self) -> PwMultiAff: ...

    def align_params(self, model: Space) -> PwMultiAff: ...

    def drop_unused_params(self) -> PwMultiAff: ...

    def coalesce(self) -> PwMultiAff: ...

    def gist_params(self, set: Set | BasicSet) -> PwMultiAff: ...

    @overload
    def gist(self, set: Set | BasicSet) -> PwMultiAff: ...

    @overload
    def gist(self, context: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def pullback_multi_aff(self, ma: MultiAff) -> PwMultiAff: ...

    def pullback_pw_multi_aff(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    def preimage_domain_wrapped_domain_pw_multi_aff(self, pma2: PwMultiAff | MultiAff) -> PwMultiAff: ...

    def n_piece(self) -> int: ...

    def foreach_piece(self, fn: Callable[[Set, MultiAff], None]) -> None: ...

    def every_piece(self, test: Callable[[Set, MultiAff], bool]) -> bool: ...

    def isa_multi_aff(self) -> bool: ...

    def as_multi_aff(self) -> MultiAff: ...

    def as_map(self) -> Map: ...

    def as_set(self) -> Set: ...

    def to_str(self) -> str: ...

    @staticmethod
    def from_set(set: Set | BasicSet) -> PwMultiAff: ...

    @staticmethod
    def from_map(map: Map | BasicMap) -> PwMultiAff: ...

    def bind_domain(self, tuple: MultiId) -> PwMultiAff: ...

    def bind_domain_wrapped_domain(self, tuple: MultiId) -> PwMultiAff: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> PwMultiAff: ...

    def dump(self) -> None: ...

    def to_union_pw_multi_aff(self) -> UnionPwMultiAff: ...

    @staticmethod
    def from_multi_pw_aff(mpa: MultiPwAff) -> PwMultiAff: ...

    def to_multi_pw_aff(self) -> MultiPwAff: ...

    def to_list(self) -> PwMultiAffList: ...

    def min_multi_val(self) -> MultiVal: ...

    def max_multi_val(self) -> MultiVal: ...

    def get_union_pw_aff(self, pos: int) -> UnionPwAff: ...

    def add_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> UnionPwMultiAff: ...

    def get_pw_multi_aff_list(self) -> PwMultiAffList: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> UnionPwMultiAff: ...

    def pullback_union_pw_multi_aff(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def apply_union_pw_multi_aff(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def preimage_domain_wrapped_domain_union_pw_multi_aff(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def n_pw_multi_aff(self) -> int: ...

    def foreach_pw_multi_aff(self, fn: Callable[[PwMultiAff], None]) -> None: ...

    def every_pw_multi_aff(self, test: Callable[[PwMultiAff], bool]) -> bool: ...

    def extract_pw_multi_aff(self, space: Space) -> PwMultiAff: ...

    def isa_pw_multi_aff(self) -> bool: ...

    def as_pw_multi_aff(self) -> PwMultiAff: ...

    def plain_is_empty(self) -> bool: ...

    def intersect_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def intersect_domain_space(self, space: Space) -> UnionPwMultiAff: ...

    def subtract_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def subtract_domain_space(self, space: Space) -> UnionPwMultiAff: ...

    def as_union_map(self) -> UnionMap: ...

    def as_multi_union_pw_aff(self) -> MultiUnionPwAff: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class UnionPwMultiAff:
    @overload
    def __init__(self, arg: PwMultiAff, /) -> None: ...

    @overload
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    @staticmethod
    def empty_ctx(ctx: Context) -> UnionPwMultiAff: ...

    @staticmethod
    def empty_space(space: Space) -> UnionPwMultiAff: ...

    @staticmethod
    def empty(space: Space) -> UnionPwMultiAff: ...

    @staticmethod
    def from_aff(aff: Aff) -> UnionPwMultiAff: ...

    @staticmethod
    def from_multi_aff(ma: MultiAff) -> UnionPwMultiAff: ...

    @staticmethod
    def from_pw_multi_aff(pma: PwMultiAff | MultiAff) -> UnionPwMultiAff: ...

    @staticmethod
    def from_domain(uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    @staticmethod
    def multi_val_on_domain(domain: UnionSet | BasicSet | Set, mv: MultiVal) -> UnionPwMultiAff: ...

    def copy(self) -> UnionPwMultiAff: ...

    def get_union_pw_aff(self, pos: int) -> UnionPwAff: ...

    def add_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> UnionPwMultiAff: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_pw_multi_aff_list(self) -> PwMultiAffList: ...

    def dim(self, type: dim_type) -> int: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> UnionPwMultiAff: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> UnionPwMultiAff: ...

    def reset_user(self) -> UnionPwMultiAff: ...

    def coalesce(self) -> UnionPwMultiAff: ...

    def gist_params(self, context: Set | BasicSet) -> UnionPwMultiAff: ...

    def gist(self, context: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def pullback_union_pw_multi_aff(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def apply_union_pw_multi_aff(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def preimage_domain_wrapped_domain_union_pw_multi_aff(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def align_params(self, model: Space) -> UnionPwMultiAff: ...

    def drop_unused_params(self) -> UnionPwMultiAff: ...

    def n_pw_multi_aff(self) -> int: ...

    def foreach_pw_multi_aff(self, fn: Callable[[PwMultiAff], None]) -> None: ...

    def every_pw_multi_aff(self, test: Callable[[PwMultiAff], bool]) -> bool: ...

    def extract_pw_multi_aff(self, space: Space) -> PwMultiAff: ...

    def isa_pw_multi_aff(self) -> bool: ...

    def as_pw_multi_aff(self) -> PwMultiAff: ...

    def plain_is_empty(self) -> bool: ...

    def involves_locals(self) -> bool: ...

    def involves_nan(self) -> bool: ...

    def plain_is_equal(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> bool: ...

    def domain(self) -> UnionSet: ...

    def neg(self) -> UnionPwMultiAff: ...

    def add(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def union_add(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def sub(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def scale_val(self, val: Val | int) -> UnionPwMultiAff: ...

    def scale_down_val(self, val: Val | int) -> UnionPwMultiAff: ...

    def scale_multi_val(self, mv: MultiVal) -> UnionPwMultiAff: ...

    def range_product(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def flat_range_product(self, upma2: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionPwMultiAff: ...

    def range_factor_domain(self) -> UnionPwMultiAff: ...

    def range_factor_range(self) -> UnionPwMultiAff: ...

    def intersect_params(self, set: Set | BasicSet) -> UnionPwMultiAff: ...

    def intersect_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def intersect_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def intersect_domain_space(self, space: Space) -> UnionPwMultiAff: ...

    def intersect_domain_wrapped_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def intersect_domain_wrapped_range(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def subtract_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def subtract_domain_space(self, space: Space) -> UnionPwMultiAff: ...

    def subtract_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    def as_union_map(self) -> UnionMap: ...

    @staticmethod
    def from_union_set(uset: UnionSet | BasicSet | Set) -> UnionPwMultiAff: ...

    @staticmethod
    def from_union_map(umap: UnionMap | BasicMap | Map) -> UnionPwMultiAff: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> UnionPwMultiAff: ...

    def dump(self) -> None: ...

    def to_str(self) -> str: ...

    @staticmethod
    def from_union_pw_aff(upa: UnionPwAff | Aff | PwAff) -> UnionPwMultiAff: ...

    @staticmethod
    def from_multi_union_pw_aff(mupa: MultiUnionPwAff) -> UnionPwMultiAff: ...

    def as_multi_union_pw_aff(self) -> MultiUnionPwAff: ...

    def to_list(self) -> UnionPwMultiAffList: ...

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class MultiPwAff:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_domain_space(self) -> Space: ...

    def get_list(self) -> PwAffList: ...

    @staticmethod
    def from_pw_aff_list(space: Space, list: PwAffList) -> MultiPwAff: ...

    def copy(self) -> MultiPwAff: ...

    def plain_is_equal(self, multi2: MultiPwAff) -> bool: ...

    def reset_user(self) -> MultiPwAff: ...

    def __len__(self) -> int: ...

    def get_at(self, pos: int) -> PwAff: ...

    def get_pw_aff(self, pos: int) -> PwAff: ...

    def set_at(self, pos: int, el: PwAff | Aff) -> MultiPwAff: ...

    def set_pw_aff(self, pos: int, el: PwAff | Aff) -> MultiPwAff: ...

    def range_splice(self, pos: int, multi2: MultiPwAff) -> MultiPwAff: ...

    def flatten_range(self) -> MultiPwAff: ...

    def flat_range_product(self, multi2: MultiPwAff) -> MultiPwAff: ...

    def range_product(self, multi2: MultiPwAff) -> MultiPwAff: ...

    def factor_range(self) -> MultiPwAff: ...

    def range_is_wrapping(self) -> bool: ...

    def range_factor_domain(self) -> MultiPwAff: ...

    def range_factor_range(self) -> MultiPwAff: ...

    def align_params(self, model: Space) -> MultiPwAff: ...

    def from_range(self) -> MultiPwAff: ...

    def identity_multi_pw_aff(self) -> MultiPwAff: ...

    @staticmethod
    def identity(space: Space) -> MultiPwAff: ...

    @staticmethod
    def identity_on_domain_space(space: Space) -> MultiPwAff: ...

    def scale_val(self, v: Val | int) -> MultiPwAff: ...

    def scale_down_val(self, v: Val | int) -> MultiPwAff: ...

    def scale_multi_val(self, mv: MultiVal) -> MultiPwAff: ...

    def scale_down_multi_val(self, mv: MultiVal) -> MultiPwAff: ...

    def mod_multi_val(self, mv: MultiVal) -> MultiPwAff: ...

    def add(self, multi2: MultiPwAff) -> MultiPwAff: ...

    def sub(self, multi2: MultiPwAff) -> MultiPwAff: ...

    def neg(self) -> MultiPwAff: ...

    def min(self, multi2: MultiPwAff) -> MultiPwAff: ...

    def max(self, multi2: MultiPwAff) -> MultiPwAff: ...

    def add_constant_val(self, v: Val | int) -> MultiPwAff: ...

    def add_constant_multi_val(self, mv: MultiVal) -> MultiPwAff: ...

    @staticmethod
    def zero(space: Space) -> MultiPwAff: ...

    def involves_nan(self) -> bool: ...

    def dim(self, type: dim_type) -> int: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> MultiPwAff: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def insert_dims(self, type: dim_type, first: int, n: int) -> MultiPwAff: ...

    def add_dims(self, type: dim_type, n: int) -> MultiPwAff: ...

    def project_domain_on_params(self) -> MultiPwAff: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def find_dim_by_id(self, type: dim_type, id: Id) -> int: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> MultiPwAff: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> MultiPwAff: ...

    def insert_domain(self, domain: Space) -> MultiPwAff: ...

    def get_tuple_name(self, type: dim_type) -> str: ...

    def has_range_tuple_id(self) -> bool: ...

    def has_tuple_id(self, type: dim_type) -> bool: ...

    def get_range_tuple_id(self) -> Id: ...

    def get_tuple_id(self, type: dim_type) -> Id: ...

    def set_tuple_name(self, type: dim_type, s: str) -> MultiPwAff: ...

    def set_range_tuple_id(self, id: Id) -> MultiPwAff: ...

    def set_tuple_id(self, type: dim_type, id: Id) -> MultiPwAff: ...

    def reset_range_tuple_id(self) -> MultiPwAff: ...

    def reset_tuple_id(self, type: dim_type) -> MultiPwAff: ...

    def product(self, multi2: MultiPwAff) -> MultiPwAff: ...

    def splice(self, in_pos: int, out_pos: int, multi2: MultiPwAff) -> MultiPwAff: ...

    def bind_domain(self, tuple: MultiId) -> MultiPwAff: ...

    def bind_domain_wrapped_domain(self, tuple: MultiId) -> MultiPwAff: ...

    def involves_param_id(self, id: Id) -> bool: ...

    def involves_param_id_list(self, list: IdList) -> bool: ...

    def unbind_params_insert_domain(self, domain: MultiId) -> MultiPwAff: ...

    def domain_reverse(self) -> MultiPwAff: ...

    def __hash__(self) -> int: ...

    @staticmethod
    def from_aff(aff: Aff) -> MultiPwAff: ...

    @staticmethod
    def from_multi_aff(ma: MultiAff) -> MultiPwAff: ...

    @staticmethod
    def from_pw_aff(pa: PwAff | Aff) -> MultiPwAff: ...

    def domain(self) -> Set: ...

    def intersect_params(self, set: Set | BasicSet) -> MultiPwAff: ...

    def intersect_domain(self, domain: Set | BasicSet) -> MultiPwAff: ...

    def coalesce(self) -> MultiPwAff: ...

    def gist(self, set: Set | BasicSet) -> MultiPwAff: ...

    def gist_params(self, set: Set | BasicSet) -> MultiPwAff: ...

    def is_cst(self) -> bool: ...

    def is_equal(self, mpa2: MultiPwAff) -> bool: ...

    def pullback_multi_aff(self, ma: MultiAff) -> MultiPwAff: ...

    def pullback_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> MultiPwAff: ...

    def pullback_multi_pw_aff(self, mpa2: MultiPwAff) -> MultiPwAff: ...

    def union_add(self, mpa2: MultiPwAff) -> MultiPwAff: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> MultiPwAff: ...

    def isa_multi_aff(self) -> bool: ...

    def as_multi_aff(self) -> MultiAff: ...

    def as_set(self) -> Set: ...

    def as_map(self) -> Map: ...

    @staticmethod
    def from_pw_multi_aff(pma: PwMultiAff | MultiAff) -> MultiPwAff: ...

    def eq_map(self, mpa2: MultiPwAff) -> Map: ...

    def lex_le_map(self, mpa2: MultiPwAff) -> Map: ...

    def lex_lt_map(self, mpa2: MultiPwAff) -> Map: ...

    def lex_ge_map(self, mpa2: MultiPwAff) -> Map: ...

    def lex_gt_map(self, mpa2: MultiPwAff) -> Map: ...

    def bind(self, tuple: MultiId) -> Set: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> MultiPwAff: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    def min_multi_val(self) -> MultiVal: ...

    def max_multi_val(self) -> MultiVal: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class MultiUnionPwAff:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_domain_space(self) -> Space: ...

    def get_list(self) -> UnionPwAffList: ...

    @staticmethod
    def from_union_pw_aff_list(space: Space, list: UnionPwAffList) -> MultiUnionPwAff: ...

    def copy(self) -> MultiUnionPwAff: ...

    def plain_is_equal(self, multi2: MultiUnionPwAff) -> bool: ...

    def reset_user(self) -> MultiUnionPwAff: ...

    def __len__(self) -> int: ...

    def get_at(self, pos: int) -> UnionPwAff: ...

    def get_union_pw_aff(self, pos: int) -> UnionPwAff: ...

    def set_at(self, pos: int, el: UnionPwAff | Aff | PwAff) -> MultiUnionPwAff: ...

    def set_union_pw_aff(self, pos: int, el: UnionPwAff | Aff | PwAff) -> MultiUnionPwAff: ...

    def range_splice(self, pos: int, multi2: MultiUnionPwAff) -> MultiUnionPwAff: ...

    def flatten_range(self) -> MultiUnionPwAff: ...

    def flat_range_product(self, multi2: MultiUnionPwAff) -> MultiUnionPwAff: ...

    def range_product(self, multi2: MultiUnionPwAff) -> MultiUnionPwAff: ...

    def factor_range(self) -> MultiUnionPwAff: ...

    def range_is_wrapping(self) -> bool: ...

    def range_factor_domain(self) -> MultiUnionPwAff: ...

    def range_factor_range(self) -> MultiUnionPwAff: ...

    def align_params(self, model: Space) -> MultiUnionPwAff: ...

    def from_range(self) -> MultiUnionPwAff: ...

    def scale_val(self, v: Val | int) -> MultiUnionPwAff: ...

    def scale_down_val(self, v: Val | int) -> MultiUnionPwAff: ...

    def scale_multi_val(self, mv: MultiVal) -> MultiUnionPwAff: ...

    def scale_down_multi_val(self, mv: MultiVal) -> MultiUnionPwAff: ...

    def mod_multi_val(self, mv: MultiVal) -> MultiUnionPwAff: ...

    def add(self, multi2: MultiUnionPwAff) -> MultiUnionPwAff: ...

    def sub(self, multi2: MultiUnionPwAff) -> MultiUnionPwAff: ...

    def neg(self) -> MultiUnionPwAff: ...

    @staticmethod
    def zero(space: Space) -> MultiUnionPwAff: ...

    def involves_nan(self) -> bool: ...

    def dim(self, type: dim_type) -> int: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> MultiUnionPwAff: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def find_dim_by_id(self, type: dim_type, id: Id) -> int: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> MultiUnionPwAff: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> MultiUnionPwAff: ...

    def get_tuple_name(self, type: dim_type) -> str: ...

    def has_range_tuple_id(self) -> bool: ...

    def has_tuple_id(self, type: dim_type) -> bool: ...

    def get_range_tuple_id(self) -> Id: ...

    def get_tuple_id(self, type: dim_type) -> Id: ...

    def set_tuple_name(self, type: dim_type, s: str) -> MultiUnionPwAff: ...

    def set_range_tuple_id(self, id: Id) -> MultiUnionPwAff: ...

    def set_tuple_id(self, type: dim_type, id: Id) -> MultiUnionPwAff: ...

    def reset_range_tuple_id(self) -> MultiUnionPwAff: ...

    def reset_tuple_id(self, type: dim_type) -> MultiUnionPwAff: ...

    @staticmethod
    def from_multi_aff(ma: MultiAff) -> MultiUnionPwAff: ...

    @staticmethod
    def from_union_pw_aff(upa: UnionPwAff | Aff | PwAff) -> MultiUnionPwAff: ...

    @staticmethod
    def from_multi_pw_aff(mpa: MultiPwAff) -> MultiUnionPwAff: ...

    @staticmethod
    def multi_val_on_domain(domain: UnionSet | BasicSet | Set, mv: MultiVal) -> MultiUnionPwAff: ...

    @staticmethod
    def multi_aff_on_domain(domain: UnionSet | BasicSet | Set, ma: MultiAff) -> MultiUnionPwAff: ...

    @staticmethod
    def pw_multi_aff_on_domain(domain: UnionSet | BasicSet | Set, pma: PwMultiAff | MultiAff) -> MultiUnionPwAff: ...

    def floor(self) -> MultiUnionPwAff: ...

    def intersect_domain(self, uset: UnionSet | BasicSet | Set) -> MultiUnionPwAff: ...

    def intersect_params(self, params: Set | BasicSet) -> MultiUnionPwAff: ...

    def intersect_range(self, set: Set | BasicSet) -> MultiUnionPwAff: ...

    def domain(self) -> UnionSet: ...

    def coalesce(self) -> MultiUnionPwAff: ...

    def gist(self, context: UnionSet | BasicSet | Set) -> MultiUnionPwAff: ...

    def gist_params(self, context: Set | BasicSet) -> MultiUnionPwAff: ...

    def apply_aff(self, aff: Aff) -> UnionPwAff: ...

    def apply_multi_aff(self, ma: MultiAff) -> MultiUnionPwAff: ...

    def apply_pw_aff(self, pa: PwAff | Aff) -> UnionPwAff: ...

    def apply_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> MultiUnionPwAff: ...

    def pullback_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> MultiUnionPwAff: ...

    def union_add(self, mupa2: MultiUnionPwAff) -> MultiUnionPwAff: ...

    @staticmethod
    def from_union_pw_multi_aff(upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> MultiUnionPwAff: ...

    @staticmethod
    def from_union_map(umap: UnionMap | BasicMap | Map) -> MultiUnionPwAff: ...

    def zero_union_set(self) -> UnionSet: ...

    def bind(self, tuple: MultiId) -> UnionSet: ...

    def extract_multi_pw_aff(self, space: Space) -> MultiPwAff: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> MultiUnionPwAff: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    def min_multi_val(self) -> MultiVal: ...

    def max_multi_val(self) -> MultiVal: ...

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class Id:
    @overload
    def __init__(self, name: str, user: object | None = None, context: Context | None = None) -> None: ...

    @overload
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def __eq__(self, other: Id) -> bool: ...

    def __ne__(self, other: Id) -> bool: ...

    def to_list(self) -> IdList: ...

    def get_ctx(self) -> Context: ...

    def __hash__(self) -> int: ...

    def get_user(self) -> object: ...

    @property
    def user(self) -> object: ...

    def get_name(self) -> str: ...

    @property
    def name(self) -> object: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> Id: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class Constraint:
    def to_list(self) -> ConstraintList: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def alloc_equality(ls: LocalSpace | Space) -> Constraint: ...

    @staticmethod
    def alloc_inequality(ls: LocalSpace | Space) -> Constraint: ...

    @staticmethod
    def equality_alloc(ls: LocalSpace | Space) -> Constraint: ...

    @staticmethod
    def inequality_alloc(ls: LocalSpace | Space) -> Constraint: ...

    def copy(self) -> Constraint: ...

    def is_equal(self, constraint2: Constraint) -> bool: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_local_space(self) -> LocalSpace: ...

    def dim(self, type: dim_type) -> int: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def get_dim_name(self, type: dim_type, pos: int) -> str | None: ...

    def get_constant_val(self) -> Val: ...

    def get_coefficient_val(self, type: dim_type, pos: int) -> Val: ...

    def set_constant_val(self, v: Val | int) -> Constraint: ...

    def set_coefficient_val(self, type: dim_type, pos: int, v: Val | int) -> Constraint: ...

    def get_div(self, pos: int) -> Aff: ...

    def negate(self) -> Constraint: ...

    def is_equality(self) -> bool: ...

    def is_div_constraint(self) -> bool: ...

    def is_lower_bound(self, type: dim_type, pos: int) -> bool: ...

    def is_upper_bound(self, type: dim_type, pos: int) -> bool: ...

    def get_bound(self, type: dim_type, pos: int) -> Aff: ...

    def get_aff(self) -> Aff: ...

    @staticmethod
    def equality_from_aff(aff: Aff) -> Constraint: ...

    @staticmethod
    def inequality_from_aff(aff: Aff) -> Constraint: ...

    def plain_cmp(self, c2: Constraint) -> int: ...

    def cmp_last_non_zero(self, c2: Constraint) -> int: ...

    def dump(self) -> None: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

    set_coefficients = islpy._monkeypatch.obj_set_coefficients

    set_coefficients_by_name = islpy._monkeypatch.obj_set_coefficients_by_name

    get_coefficients_by_name = islpy._monkeypatch.obj_get_coefficients_by_name

    eq_from_names = staticmethod(islpy._monkeypatch.eq_from_names)

    ineq_from_names = staticmethod(islpy._monkeypatch.ineq_from_names)

class Space:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def to_local_space(self) -> LocalSpace: ...

    def multi_id(self, list: IdList) -> MultiId: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def unit(ctx: Context) -> Space: ...

    @staticmethod
    def alloc(ctx: Context, nparam: int, n_in: int, n_out: int) -> Space: ...

    @staticmethod
    def set_alloc(ctx: Context, nparam: int, dim: int) -> Space: ...

    @staticmethod
    def params_alloc(ctx: Context, nparam: int) -> Space: ...

    def copy(self) -> Space: ...

    def is_params(self) -> bool: ...

    def is_set(self) -> bool: ...

    def is_map(self) -> bool: ...

    def add_param_id(self, id: Id) -> Space: ...

    def set_tuple_name(self, type: dim_type, s: str) -> Space: ...

    def has_tuple_name(self, type: dim_type) -> bool: ...

    def get_tuple_name(self, type: dim_type) -> str: ...

    def set_domain_tuple_id(self, id: Id) -> Space: ...

    def set_range_tuple_id(self, id: Id) -> Space: ...

    def set_tuple_id(self, type: dim_type, id: Id) -> Space: ...

    def reset_tuple_id(self, type: dim_type) -> Space: ...

    def has_domain_tuple_id(self) -> bool: ...

    def has_range_tuple_id(self) -> bool: ...

    def has_tuple_id(self, type: dim_type) -> bool: ...

    def get_domain_tuple_id(self) -> Id: ...

    def get_range_tuple_id(self) -> Id: ...

    def get_tuple_id(self, type: dim_type) -> Id: ...

    def reset_user(self) -> Space: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> Space: ...

    def has_dim_id(self, type: dim_type, pos: int) -> bool: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def find_dim_by_id(self, type: dim_type, id: Id) -> int: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def has_dim_name(self, type: dim_type, pos: int) -> bool: ...

    def set_dim_name(self, type: dim_type, pos: int, name: str) -> Space: ...

    def get_dim_name(self, type: dim_type, pos: int) -> str | None: ...

    def extend(self, nparam: int, n_in: int, n_out: int) -> Space: ...

    def add_dims(self, type: dim_type, n: int) -> Space: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> Space: ...

    def insert_dims(self, type: dim_type, pos: int, n: int) -> Space: ...

    def join(self, right: Space) -> Space: ...

    def product(self, right: Space) -> Space: ...

    def domain_product(self, right: Space) -> Space: ...

    def range_product(self, right: Space) -> Space: ...

    def factor_domain(self) -> Space: ...

    def factor_range(self) -> Space: ...

    def domain_factor_domain(self) -> Space: ...

    def domain_factor_range(self) -> Space: ...

    def range_factor_domain(self) -> Space: ...

    def range_factor_range(self) -> Space: ...

    def domain_wrapped_domain(self) -> Space: ...

    def domain_wrapped_range(self) -> Space: ...

    def range_wrapped_domain(self) -> Space: ...

    def range_wrapped_range(self) -> Space: ...

    def map_from_set(self) -> Space: ...

    def map_from_domain_and_range(self, range: Space) -> Space: ...

    def reverse(self) -> Space: ...

    def wrapped_reverse(self) -> Space: ...

    def domain_reverse(self) -> Space: ...

    def range_reverse(self) -> Space: ...

    def drop_dims(self, type: dim_type, first: int, num: int) -> Space: ...

    def drop_inputs(self, first: int, n: int) -> Space: ...

    def drop_outputs(self, first: int, n: int) -> Space: ...

    def drop_all_params(self) -> Space: ...

    def domain(self) -> Space: ...

    def from_domain(self) -> Space: ...

    def range(self) -> Space: ...

    def from_range(self) -> Space: ...

    def domain_map(self) -> Space: ...

    def range_map(self) -> Space: ...

    def params(self) -> Space: ...

    def add_unnamed_tuple_ui(self, dim: int) -> Space: ...

    def add_named_tuple_id_ui(self, tuple_id: Id, dim: int) -> Space: ...

    def set_from_params(self) -> Space: ...

    def align_params(self, space2: Space) -> Space: ...

    def is_wrapping(self) -> bool: ...

    def domain_is_wrapping(self) -> bool: ...

    def range_is_wrapping(self) -> bool: ...

    def is_product(self) -> bool: ...

    def wrap(self) -> Space: ...

    def unwrap(self) -> Space: ...

    def can_zip(self) -> bool: ...

    def zip(self) -> Space: ...

    def can_curry(self) -> bool: ...

    def curry(self) -> Space: ...

    def can_range_curry(self) -> bool: ...

    def range_curry(self) -> Space: ...

    def can_uncurry(self) -> bool: ...

    def uncurry(self) -> Space: ...

    def is_domain(self, space2: Space) -> bool: ...

    def is_range(self, space2: Space) -> bool: ...

    @overload
    def is_equal(self, space2: Space) -> bool: ...

    @overload
    def is_equal(self, ls2: LocalSpace | Space) -> bool: ...

    def has_equal_params(self, space2: Space) -> bool: ...

    def has_equal_tuples(self, space2: Space) -> bool: ...

    def tuple_is_equal(self, type1: dim_type, space2: Space, type2: dim_type) -> bool: ...

    def match(self, type1: dim_type, space2: Space, type2: dim_type) -> bool: ...

    def dim(self, type: dim_type) -> int: ...

    def flatten_domain(self) -> Space: ...

    def flatten_range(self) -> Space: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> Space: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    def universe_set(self) -> Set: ...

    def universe_map(self) -> Map: ...

    def zero_aff_on_domain(self) -> Aff: ...

    def param_aff_on_domain_id(self, id: Id) -> Aff: ...

    def multi_aff(self, list: AffList) -> MultiAff: ...

    def identity_multi_aff_on_domain(self) -> MultiAff: ...

    def zero_multi_aff(self) -> MultiAff: ...

    def domain_map_multi_aff(self) -> MultiAff: ...

    def range_map_multi_aff(self) -> MultiAff: ...

    def multi_aff_on_domain_multi_val(self, mv: MultiVal) -> MultiAff: ...

    def multi_pw_aff(self, list: PwAffList) -> MultiPwAff: ...

    def identity_multi_pw_aff_on_domain(self) -> MultiPwAff: ...

    def zero_multi_pw_aff(self) -> MultiPwAff: ...

    def identity_pw_multi_aff_on_domain(self) -> PwMultiAff: ...

    def domain_map_pw_multi_aff(self) -> PwMultiAff: ...

    def range_map_pw_multi_aff(self) -> PwMultiAff: ...

    def multi_union_pw_aff(self, list: UnionPwAffList) -> MultiUnionPwAff: ...

    def zero_multi_union_pw_aff(self) -> MultiUnionPwAff: ...

    def multi_val(self, list: ValList) -> MultiVal: ...

    def zero_multi_val(self) -> MultiVal: ...

    def get_space(self) -> Space: ...

    def get_div(self, pos: int) -> Aff: ...

    def intersect(self, ls2: LocalSpace | Space) -> LocalSpace: ...

    def lifting(self) -> BasicMap: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    get_id_dict = islpy._monkeypatch.space_get_id_dict

    get_var_dict = islpy._monkeypatch.space_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

    create_from_names = staticmethod(islpy._monkeypatch.space_create_from_names)

class LocalSpace:
    def __init__(self, arg: Space, /) -> None: ...

    def get_ctx(self) -> Context: ...

    @staticmethod
    def from_space(space: Space) -> LocalSpace: ...

    def copy(self) -> LocalSpace: ...

    def is_params(self) -> bool: ...

    def is_set(self) -> bool: ...

    def set_tuple_id(self, type: dim_type, id: Id) -> LocalSpace: ...

    def dim(self, type: dim_type) -> int: ...

    def has_dim_name(self, type: dim_type, pos: int) -> bool: ...

    def get_dim_name(self, type: dim_type, pos: int) -> str | None: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> LocalSpace: ...

    def has_dim_id(self, type: dim_type, pos: int) -> bool: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> LocalSpace: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_div(self, pos: int) -> Aff: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def domain(self) -> LocalSpace: ...

    def range(self) -> LocalSpace: ...

    def from_domain(self) -> LocalSpace: ...

    def add_dims(self, type: dim_type, n: int) -> LocalSpace: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> LocalSpace: ...

    def insert_dims(self, type: dim_type, first: int, n: int) -> LocalSpace: ...

    def set_from_params(self) -> LocalSpace: ...

    def intersect(self, ls2: LocalSpace | Space) -> LocalSpace: ...

    def wrap(self) -> LocalSpace: ...

    def is_equal(self, ls2: LocalSpace | Space) -> bool: ...

    def lifting(self) -> BasicMap: ...

    def flatten_domain(self) -> LocalSpace: ...

    def flatten_range(self) -> LocalSpace: ...

    def dump(self) -> None: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class BasicSet:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def __hash__(self) -> int: ...

    def is_params(self) -> bool: ...

    def n_dim(self) -> int: ...

    def n_param(self) -> int: ...

    def total_dim(self) -> int: ...

    def dim(self, type: dim_type) -> int: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_div(self, pos: int) -> Aff: ...

    def get_local_space(self) -> LocalSpace: ...

    def get_tuple_name(self) -> str: ...

    def set_tuple_name(self, s: str) -> BasicSet: ...

    def get_dim_name(self, type: dim_type, pos: int) -> str | None: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> BasicSet: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def set_tuple_id(self, id: Id) -> BasicSet: ...

    def is_rational(self) -> bool: ...

    def copy(self) -> BasicSet: ...

    @staticmethod
    def empty(space: Space) -> BasicSet: ...

    @staticmethod
    def universe(space: Space) -> BasicSet: ...

    @staticmethod
    def nat_universe(space: Space) -> BasicSet: ...

    @staticmethod
    def positive_orthant(space: Space) -> BasicSet: ...

    @overload
    def intersect(self, bset2: BasicSet) -> BasicSet: ...

    @overload
    def intersect(self, set2: Set | BasicSet) -> Set: ...

    @overload
    def intersect(self, uset2: UnionSet | BasicSet | Set) -> UnionSet: ...

    @overload
    def intersect_params(self, bset2: BasicSet) -> BasicSet: ...

    @overload
    def intersect_params(self, params: Set | BasicSet) -> Set: ...

    @overload
    def apply(self, bmap: BasicMap) -> BasicSet: ...

    @overload
    def apply(self, map: Map | BasicMap) -> Set: ...

    @overload
    def apply(self, umap: UnionMap | BasicMap | Map) -> UnionSet: ...

    def preimage_multi_aff(self, ma: MultiAff) -> BasicSet: ...

    def affine_hull(self) -> BasicSet: ...

    def remove_dims(self, type: dim_type, first: int, n: int) -> BasicSet: ...

    def sample(self) -> BasicSet: ...

    def detect_equalities(self) -> BasicSet: ...

    def remove_redundancies(self) -> BasicSet: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> BasicSet: ...

    def dump(self) -> None: ...

    def fix_val(self, type: dim_type, pos: int, v: Val | int) -> BasicSet: ...

    def lower_bound_val(self, type: dim_type, pos: int, value: Val | int) -> BasicSet: ...

    def upper_bound_val(self, type: dim_type, pos: int, value: Val | int) -> BasicSet: ...

    @overload
    def is_equal(self, bset2: BasicSet) -> bool: ...

    @overload
    def is_equal(self, set2: Set | BasicSet) -> bool: ...

    @overload
    def is_equal(self, uset2: UnionSet | BasicSet | Set) -> bool: ...

    @overload
    def is_disjoint(self, bset2: BasicSet) -> bool: ...

    @overload
    def is_disjoint(self, set2: Set | BasicSet) -> bool: ...

    @overload
    def is_disjoint(self, uset2: UnionSet | BasicSet | Set) -> bool: ...

    @overload
    def partial_lexmin(self, dom: BasicSet) -> tuple[Set, Set]: ...

    @overload
    def partial_lexmin(self, dom: Set | BasicSet) -> tuple[Set, Set]: ...

    @overload
    def partial_lexmax(self, dom: BasicSet) -> tuple[Set, Set]: ...

    @overload
    def partial_lexmax(self, dom: Set | BasicSet) -> tuple[Set, Set]: ...

    def lexmin(self) -> Set: ...

    def lexmax(self) -> Set: ...

    def partial_lexmin_pw_multi_aff(self, dom: BasicSet) -> tuple[PwMultiAff, Set]: ...

    def partial_lexmax_pw_multi_aff(self, dom: BasicSet) -> tuple[PwMultiAff, Set]: ...

    @overload
    def union(self, bset2: BasicSet) -> Set: ...

    @overload
    def union(self, set2: Set | BasicSet) -> Set: ...

    @overload
    def union(self, uset2: UnionSet | BasicSet | Set) -> UnionSet: ...

    def compare_at(self, bset2: BasicSet, pos: int) -> int: ...

    def params(self) -> BasicSet: ...

    def from_params(self) -> BasicSet: ...

    def plain_is_universe(self) -> bool: ...

    def is_universe(self) -> bool: ...

    def plain_is_empty(self) -> bool: ...

    def is_empty(self) -> bool: ...

    def is_bounded(self) -> bool: ...

    @overload
    def is_subset(self, bset2: BasicSet) -> bool: ...

    @overload
    def is_subset(self, set2: Set | BasicSet) -> bool: ...

    @overload
    def is_subset(self, uset2: UnionSet | BasicSet | Set) -> bool: ...

    @overload
    def plain_is_equal(self, bset2: BasicSet) -> bool: ...

    @overload
    def plain_is_equal(self, set2: Set | BasicSet) -> bool: ...

    def to_set(self) -> Set: ...

    def sample_point(self) -> Point: ...

    @overload
    def flat_product(self, bset2: BasicSet) -> BasicSet: ...

    @overload
    def flat_product(self, set2: Set | BasicSet) -> Set: ...

    def insert_dims(self, type: dim_type, pos: int, n: int) -> BasicSet: ...

    def add_dims(self, type: dim_type, n: int) -> BasicSet: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> BasicSet: ...

    def project_out(self, type: dim_type, first: int, n: int) -> BasicSet: ...

    def remove_divs(self) -> BasicSet: ...

    def eliminate(self, type: dim_type, first: int, n: int) -> BasicSet: ...

    def remove_divs_involving_dims(self, type: dim_type, first: int, n: int) -> BasicSet: ...

    def remove_unknown_divs(self) -> BasicSet: ...

    def drop_constraints_involving_dims(self, type: dim_type, first: int, n: int) -> BasicSet: ...

    def drop_constraints_not_involving_dims(self, type: dim_type, first: int, n: int) -> BasicSet: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def neg(self) -> BasicSet: ...

    def compute_divs(self) -> Set: ...

    @overload
    def gist(self, context: BasicSet) -> BasicSet: ...

    @overload
    def gist(self, context: Set | BasicSet) -> Set: ...

    @overload
    def gist(self, context: UnionSet | BasicSet | Set) -> UnionSet: ...

    @staticmethod
    def from_point(pnt: Point) -> BasicSet: ...

    @staticmethod
    def box_from_points(pnt1: Point, pnt2: Point) -> BasicSet: ...

    def lift(self) -> BasicSet: ...

    def align_params(self, model: Space) -> BasicSet: ...

    def drop_unused_params(self) -> BasicSet: ...

    def equalities_matrix(self, c1: dim_type, c2: dim_type, c3: dim_type, c4: dim_type) -> Mat: ...

    def inequalities_matrix(self, c1: dim_type, c2: dim_type, c3: dim_type, c4: dim_type) -> Mat: ...

    @staticmethod
    def from_constraint_matrices(space: Space, eq: Mat, ineq: Mat, c1: dim_type, c2: dim_type, c3: dim_type, c4: dim_type) -> BasicSet: ...

    @staticmethod
    def from_multi_aff(ma: MultiAff) -> BasicSet: ...

    def reduced_basis(self) -> Mat: ...

    def coefficients(self) -> BasicSet: ...

    def solutions(self) -> BasicSet: ...

    def to_str(self) -> str: ...

    def is_wrapping(self) -> bool: ...

    def unwrap(self) -> BasicMap: ...

    def flatten(self) -> BasicSet: ...

    def to_list(self) -> BasicSetList: ...

    def compute_vertices(self) -> Vertices: ...

    def n_constraint(self) -> int: ...

    def foreach_constraint(self, fn: Callable[[Constraint], None]) -> None: ...

    def get_constraint_list(self) -> ConstraintList: ...

    def foreach_bound_pair(self, type: dim_type, pos: int, fn: Callable[[Constraint, Constraint, BasicSet], None]) -> None: ...

    def add_constraint(self, constraint: Constraint) -> BasicSet: ...

    @staticmethod
    def from_constraint(constraint: Constraint) -> BasicSet: ...

    def max_val(self, obj: Aff) -> Val: ...

    def dim_max_val(self, pos: int) -> Val: ...

    def tuple_dim(self) -> int: ...

    def reset_space(self, space: Space) -> Set: ...

    def has_tuple_name(self) -> bool: ...

    def has_dim_name(self, type: dim_type, pos: int) -> bool: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> Set: ...

    def has_dim_id(self, type: dim_type, pos: int) -> bool: ...

    def reset_tuple_id(self) -> Set: ...

    def has_tuple_id(self) -> bool: ...

    def get_tuple_id(self) -> Id: ...

    def reset_user(self) -> Set: ...

    def find_dim_by_id(self, type: dim_type, id: Id) -> int: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def lower_bound_multi_val(self, lower: MultiVal) -> Set: ...

    def upper_bound_multi_val(self, upper: MultiVal) -> Set: ...

    def lower_bound_multi_pw_aff(self, lower: MultiPwAff) -> Set: ...

    def upper_bound_multi_pw_aff(self, upper: MultiPwAff) -> Set: ...

    def equate(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> Set: ...

    def lexmin_pw_multi_aff(self) -> PwMultiAff: ...

    def lexmax_pw_multi_aff(self) -> PwMultiAff: ...

    def min_multi_pw_aff(self) -> MultiPwAff: ...

    def max_multi_pw_aff(self) -> MultiPwAff: ...

    def follows_at(self, set2: Set | BasicSet, pos: int) -> int: ...

    def bind(self, tuple: MultiId) -> Set: ...

    def unbind_params(self, tuple: MultiId) -> Set: ...

    def unbind_params_insert_domain(self, domain: MultiId) -> Map: ...

    def convex_hull(self) -> BasicSet: ...

    def polyhedral_hull(self) -> BasicSet: ...

    def simple_hull(self) -> BasicSet: ...

    def unshifted_simple_hull(self) -> BasicSet: ...

    def plain_unshifted_simple_hull(self) -> BasicSet: ...

    def unshifted_simple_hull_from_set_list(self, list: SetList) -> BasicSet: ...

    def bounded_simple_hull(self) -> BasicSet: ...

    def wrapped_reverse(self) -> Set: ...

    def union_disjoint(self, set2: Set | BasicSet) -> Set: ...

    @overload
    def product(self, set2: Set | BasicSet) -> Set: ...

    @overload
    def product(self, uset2: UnionSet | BasicSet | Set) -> UnionSet: ...

    def intersect_factor_domain(self, domain: Set | BasicSet) -> Set: ...

    def intersect_factor_range(self, range: Set | BasicSet) -> Set: ...

    @overload
    def subtract(self, set2: Set | BasicSet) -> Set: ...

    @overload
    def subtract(self, uset2: UnionSet | BasicSet | Set) -> UnionSet: ...

    def complement(self) -> Set: ...

    def preimage_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> Set: ...

    def preimage_multi_pw_aff(self, mpa: MultiPwAff) -> Set: ...

    def fix_dim_si(self, dim: int, value: int) -> Set: ...

    def project_out_param_id(self, id: Id) -> Set: ...

    def project_out_param_id_list(self, list: IdList) -> Set: ...

    def project_out_all_params(self) -> Set: ...

    def project_onto_map(self, type: dim_type, first: int, n: int) -> Map: ...

    def eliminate_dims(self, first: int, n: int) -> Set: ...

    def split_dims(self, type: dim_type, first: int, n: int) -> Set: ...

    def involves_locals(self) -> bool: ...

    @overload
    def is_strict_subset(self, set2: Set | BasicSet) -> bool: ...

    @overload
    def is_strict_subset(self, uset2: UnionSet | BasicSet | Set) -> bool: ...

    def is_singleton(self) -> bool: ...

    def is_box(self) -> bool: ...

    def has_equal_space(self, set2: Set | BasicSet) -> bool: ...

    def sum(self, set2: Set | BasicSet) -> Set: ...

    def make_disjoint(self) -> Set: ...

    def align_divs(self) -> Set: ...

    def get_plain_multi_val_if_fixed(self) -> MultiVal: ...

    def plain_get_val_if_fixed(self, type: dim_type, pos: int) -> Val: ...

    def dim_is_bounded(self, type: dim_type, pos: int) -> bool: ...

    def dim_has_lower_bound(self, type: dim_type, pos: int) -> bool: ...

    def dim_has_upper_bound(self, type: dim_type, pos: int) -> bool: ...

    def dim_has_any_lower_bound(self, type: dim_type, pos: int) -> bool: ...

    def dim_has_any_upper_bound(self, type: dim_type, pos: int) -> bool: ...

    def gist_basic_set(self, context: BasicSet) -> Set: ...

    def gist_params(self, context: Set | BasicSet) -> Set: ...

    def dim_residue_class_val(self, pos: int) -> tuple[Val, Val]: ...

    def get_stride_info(self, pos: int) -> StrideInfo: ...

    def get_stride(self, pos: int) -> Val: ...

    def get_lattice_tile(self) -> FixedBox: ...

    def get_simple_fixed_box_hull(self) -> FixedBox: ...

    def coalesce(self) -> Set: ...

    def plain_cmp(self, set2: Set | BasicSet) -> int: ...

    def plain_is_disjoint(self, set2: Set | BasicSet) -> bool: ...

    def n_basic_set(self) -> int: ...

    def foreach_basic_set(self, fn: Callable[[BasicSet], None]) -> None: ...

    def get_basic_set_list(self) -> BasicSetList: ...

    def foreach_point(self, fn: Callable[[Point], None]) -> None: ...

    def count_val(self) -> Val: ...

    def lex_le_set(self, set2: Set | BasicSet) -> Map: ...

    def lex_lt_set(self, set2: Set | BasicSet) -> Map: ...

    def lex_ge_set(self, set2: Set | BasicSet) -> Map: ...

    def lex_gt_set(self, set2: Set | BasicSet) -> Map: ...

    def __len__(self) -> int: ...

    def dim_max(self, pos: int) -> PwAff: ...

    def dim_min(self, pos: int) -> PwAff: ...

    def translation(self) -> Map: ...

    def identity(self) -> Map: ...

    def flatten_map(self) -> Map: ...

    def insert_domain(self, domain: Space) -> Map: ...

    def wrapped_domain_map(self) -> Map: ...

    def pw_aff_on_domain_val(self, v: Val | int) -> PwAff: ...

    def param_pw_aff_on_domain_id(self, id: Id) -> PwAff: ...

    def indicator_function(self) -> PwAff: ...

    def pw_multi_aff_on_domain_multi_val(self, mv: MultiVal) -> PwMultiAff: ...

    def as_pw_multi_aff(self) -> PwMultiAff: ...

    def apply_pw_qpolynomial_fold(self, pwf: PwQPolynomialFold) -> tuple[PwQPolynomialFold, bool]: ...

    def to_union_set(self) -> UnionSet: ...

    def min_val(self, obj: Aff) -> Val: ...

    def dim_min_val(self, pos: int) -> Val: ...

    def identity_union_pw_multi_aff(self) -> UnionPwMultiAff: ...

    def apply_union_pw_qpolynomial_fold(self, upwf: UnionPwQPolynomialFold) -> tuple[UnionPwQPolynomialFold, bool]: ...

    def add_set(self, set: Set | BasicSet) -> UnionSet: ...

    def preimage_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionSet: ...

    def n_set(self) -> int: ...

    def foreach_set(self, fn: Callable[[Set], None]) -> None: ...

    def every_set(self, test: Callable[[Set], bool]) -> bool: ...

    def get_set_list(self) -> SetList: ...

    def contains(self, space: Space) -> bool: ...

    def extract_set(self, space: Space) -> Set: ...

    def isa_set(self) -> bool: ...

    def as_set(self) -> Set: ...

    def lex_lt_union_set(self, uset2: UnionSet | BasicSet | Set) -> UnionMap: ...

    def lex_le_union_set(self, uset2: UnionSet | BasicSet | Set) -> UnionMap: ...

    def lex_gt_union_set(self, uset2: UnionSet | BasicSet | Set) -> UnionMap: ...

    def lex_ge_union_set(self, uset2: UnionSet | BasicSet | Set) -> UnionMap: ...

    def compute_schedule(self, validity: UnionMap | BasicMap | Map, proximity: UnionMap | BasicMap | Map) -> Schedule: ...

    def min_multi_union_pw_aff(self, obj: MultiUnionPwAff) -> MultiVal: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    __lt__ = islpy._monkeypatch.set_lt

    __le__ = islpy._monkeypatch.set_le

    __gt__ = islpy._monkeypatch.set_gt

    __ge__ = islpy._monkeypatch.set_ge

    project_out_except = islpy._monkeypatch.obj_project_out_except

    add_constraints = islpy._monkeypatch.obj_add_constraints

    eliminate_except = islpy._monkeypatch.obj_eliminate_except

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

    __and__ = islpy._monkeypatch.bset_and

    __rand__ = islpy._monkeypatch.bset_and

    __or__ = islpy._monkeypatch.set_or

    __ror__ = islpy._monkeypatch.set_or

    __sub__ = islpy._monkeypatch.set_sub

    get_constraints = islpy._monkeypatch.basic_obj_get_constraints

    get_basic_sets = islpy._monkeypatch.set_get_basic_sets

class BasicMap:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def __hash__(self) -> int: ...

    def to_map(self) -> Map: ...

    def total_dim(self) -> int: ...

    def dim(self, type: dim_type) -> int: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_div(self, pos: int) -> Aff: ...

    def get_local_space(self) -> LocalSpace: ...

    def set_tuple_name(self, type: dim_type, s: str) -> BasicMap: ...

    def get_tuple_name(self, type: dim_type) -> str: ...

    def get_dim_name(self, type: dim_type, pos: int) -> str | None: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> BasicMap: ...

    def set_tuple_id(self, type: dim_type, id: Id) -> BasicMap: ...

    def has_dim_id(self, type: dim_type, pos: int) -> bool: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def is_rational(self) -> bool: ...

    @staticmethod
    def identity(space: Space) -> BasicMap: ...

    def copy(self) -> BasicMap: ...

    @staticmethod
    def equal(space: Space, n_equal: int) -> BasicMap: ...

    @staticmethod
    def less_at(space: Space, pos: int) -> BasicMap: ...

    @staticmethod
    def more_at(space: Space, pos: int) -> BasicMap: ...

    @staticmethod
    def empty(space: Space) -> BasicMap: ...

    @staticmethod
    def universe(space: Space) -> BasicMap: ...

    @staticmethod
    def nat_universe(space: Space) -> BasicMap: ...

    def remove_redundancies(self) -> BasicMap: ...

    @overload
    def intersect_params(self, bset: BasicSet) -> BasicMap: ...

    @overload
    def intersect_params(self, params: Set | BasicSet) -> Map: ...

    @overload
    def intersect_domain(self, bset: BasicSet) -> BasicMap: ...

    @overload
    def intersect_domain(self, set: Set | BasicSet) -> Map: ...

    @overload
    def intersect_domain(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    @overload
    def intersect_range(self, bset: BasicSet) -> BasicMap: ...

    @overload
    def intersect_range(self, set: Set | BasicSet) -> Map: ...

    @overload
    def intersect_range(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    @overload
    def intersect(self, bmap2: BasicMap) -> BasicMap: ...

    @overload
    def intersect(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def intersect(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def union(self, bmap2: BasicMap) -> Map: ...

    @overload
    def union(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def union(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def apply_domain(self, bmap2: BasicMap) -> BasicMap: ...

    @overload
    def apply_domain(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def apply_domain(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def apply_range(self, bmap2: BasicMap) -> BasicMap: ...

    @overload
    def apply_range(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def apply_range(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def affine_hull(self) -> BasicMap: ...

    def preimage_domain_multi_aff(self, ma: MultiAff) -> BasicMap: ...

    def preimage_range_multi_aff(self, ma: MultiAff) -> BasicMap: ...

    def reverse(self) -> BasicMap: ...

    def domain(self) -> BasicSet: ...

    def range(self) -> BasicSet: ...

    def domain_map(self) -> BasicMap: ...

    def range_map(self) -> BasicMap: ...

    def remove_dims(self, type: dim_type, first: int, n: int) -> BasicMap: ...

    def eliminate(self, type: dim_type, first: int, n: int) -> BasicMap: ...

    def sample(self) -> BasicMap: ...

    def detect_equalities(self) -> BasicMap: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> BasicMap: ...

    def dump(self) -> None: ...

    def to_str(self) -> str: ...

    def fix_val(self, type: dim_type, pos: int, v: Val | int) -> BasicMap: ...

    def lower_bound_si(self, type: dim_type, pos: int, value: int) -> BasicMap: ...

    def upper_bound_si(self, type: dim_type, pos: int, value: int) -> BasicMap: ...

    @overload
    def sum(self, bmap2: BasicMap) -> BasicMap: ...

    @overload
    def sum(self, map2: Map | BasicMap) -> Map: ...

    def neg(self) -> BasicMap: ...

    @overload
    def is_equal(self, bmap2: BasicMap) -> bool: ...

    @overload
    def is_equal(self, map2: Map | BasicMap) -> bool: ...

    @overload
    def is_equal(self, umap2: UnionMap | BasicMap | Map) -> bool: ...

    @overload
    def is_disjoint(self, bmap2: BasicMap) -> bool: ...

    @overload
    def is_disjoint(self, map2: Map | BasicMap) -> bool: ...

    @overload
    def is_disjoint(self, umap2: UnionMap | BasicMap | Map) -> bool: ...

    @overload
    def partial_lexmax(self, dom: BasicSet) -> tuple[Map, Set]: ...

    @overload
    def partial_lexmax(self, dom: Set | BasicSet) -> tuple[Map, Set]: ...

    @overload
    def partial_lexmin(self, dom: BasicSet) -> tuple[Map, Set]: ...

    @overload
    def partial_lexmin(self, dom: Set | BasicSet) -> tuple[Map, Set]: ...

    def lexmin(self) -> Map: ...

    def lexmax(self) -> Map: ...

    def partial_lexmin_pw_multi_aff(self, dom: BasicSet) -> tuple[PwMultiAff, Set]: ...

    def partial_lexmax_pw_multi_aff(self, dom: BasicSet) -> tuple[PwMultiAff, Set]: ...

    def lexmin_pw_multi_aff(self) -> PwMultiAff: ...

    def plain_get_val_if_fixed(self, type: dim_type, pos: int) -> Val: ...

    def image_is_bounded(self) -> bool: ...

    def plain_is_universe(self) -> bool: ...

    def is_universe(self) -> bool: ...

    def plain_is_empty(self) -> bool: ...

    def is_empty(self) -> bool: ...

    @overload
    def is_subset(self, bmap2: BasicMap) -> bool: ...

    @overload
    def is_subset(self, map2: Map | BasicMap) -> bool: ...

    @overload
    def is_subset(self, umap2: UnionMap | BasicMap | Map) -> bool: ...

    @overload
    def is_strict_subset(self, bmap2: BasicMap) -> bool: ...

    @overload
    def is_strict_subset(self, map2: Map | BasicMap) -> bool: ...

    @overload
    def is_strict_subset(self, umap2: UnionMap | BasicMap | Map) -> bool: ...

    @overload
    def product(self, bmap2: BasicMap) -> BasicMap: ...

    @overload
    def product(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def domain_product(self, bmap2: BasicMap) -> BasicMap: ...

    @overload
    def domain_product(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def domain_product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def range_product(self, bmap2: BasicMap) -> BasicMap: ...

    @overload
    def range_product(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def range_product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def flat_product(self, bmap2: BasicMap) -> BasicMap: ...

    @overload
    def flat_product(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def flat_range_product(self, bmap2: BasicMap) -> BasicMap: ...

    @overload
    def flat_range_product(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def flat_range_product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def deltas(self) -> BasicSet: ...

    def deltas_map(self) -> BasicMap: ...

    def add_dims(self, type: dim_type, n: int) -> BasicMap: ...

    def insert_dims(self, type: dim_type, pos: int, n: int) -> BasicMap: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> BasicMap: ...

    def project_out(self, type: dim_type, first: int, n: int) -> BasicMap: ...

    def remove_divs(self) -> BasicMap: ...

    def remove_divs_involving_dims(self, type: dim_type, first: int, n: int) -> BasicMap: ...

    def equate(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> BasicMap: ...

    def order_ge(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> BasicMap: ...

    def order_gt(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> BasicMap: ...

    def wrap(self) -> BasicSet: ...

    def flatten(self) -> BasicMap: ...

    def flatten_domain(self) -> BasicMap: ...

    def flatten_range(self) -> BasicMap: ...

    @staticmethod
    def from_domain(bset: BasicSet) -> BasicMap: ...

    @staticmethod
    def from_range(bset: BasicSet) -> BasicMap: ...

    @staticmethod
    def from_domain_and_range(domain: BasicSet, range: BasicSet) -> BasicMap: ...

    def is_single_valued(self) -> bool: ...

    def can_zip(self) -> bool: ...

    def zip(self) -> BasicMap: ...

    def can_curry(self) -> bool: ...

    def curry(self) -> BasicMap: ...

    def can_uncurry(self) -> bool: ...

    def uncurry(self) -> BasicMap: ...

    def compute_divs(self) -> Map: ...

    def drop_constraints_involving_dims(self, type: dim_type, first: int, n: int) -> BasicMap: ...

    def drop_constraints_not_involving_dims(self, type: dim_type, first: int, n: int) -> BasicMap: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    @overload
    def gist_domain(self, context: BasicSet) -> BasicMap: ...

    @overload
    def gist_domain(self, context: Set | BasicSet) -> Map: ...

    @overload
    def gist_domain(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    @overload
    def gist(self, context: BasicMap) -> BasicMap: ...

    @overload
    def gist(self, context: Map | BasicMap) -> Map: ...

    @overload
    def gist(self, context: UnionMap | BasicMap | Map) -> UnionMap: ...

    def align_params(self, model: Space) -> BasicMap: ...

    def drop_unused_params(self) -> BasicMap: ...

    def equalities_matrix(self, c1: dim_type, c2: dim_type, c3: dim_type, c4: dim_type, c5: dim_type) -> Mat: ...

    def inequalities_matrix(self, c1: dim_type, c2: dim_type, c3: dim_type, c4: dim_type, c5: dim_type) -> Mat: ...

    @staticmethod
    def from_constraint_matrices(space: Space, eq: Mat, ineq: Mat, c1: dim_type, c2: dim_type, c3: dim_type, c4: dim_type, c5: dim_type) -> BasicMap: ...

    @staticmethod
    def from_aff(aff: Aff) -> BasicMap: ...

    @staticmethod
    def from_multi_aff(maff: MultiAff) -> BasicMap: ...

    @staticmethod
    def from_aff_list(domain_space: Space, list: AffList) -> BasicMap: ...

    def to_list(self) -> BasicMapList: ...

    @staticmethod
    def from_qpolynomial(qp: QPolynomial) -> BasicMap: ...

    def n_constraint(self) -> int: ...

    def foreach_constraint(self, fn: Callable[[Constraint], None]) -> None: ...

    def get_constraint_list(self) -> ConstraintList: ...

    def add_constraint(self, constraint: Constraint) -> BasicMap: ...

    def has_defining_equality(self, type: dim_type, pos: int) -> Constraint: ...

    @staticmethod
    def from_constraint(constraint: Constraint) -> BasicMap: ...

    def domain_tuple_dim(self) -> int: ...

    def range_tuple_dim(self) -> int: ...

    def has_tuple_name(self, type: dim_type) -> bool: ...

    def has_dim_name(self, type: dim_type, pos: int) -> bool: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> Map: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def set_domain_tuple_id(self, id: Id) -> Map: ...

    def set_range_tuple_id(self, id: Id) -> Map: ...

    def reset_tuple_id(self, type: dim_type) -> Map: ...

    def has_domain_tuple_id(self) -> bool: ...

    def has_range_tuple_id(self) -> bool: ...

    def has_tuple_id(self, type: dim_type) -> bool: ...

    def get_domain_tuple_id(self) -> Id: ...

    def get_range_tuple_id(self) -> Id: ...

    def get_tuple_id(self, type: dim_type) -> Id: ...

    def reset_user(self) -> Map: ...

    def find_dim_by_id(self, type: dim_type, id: Id) -> int: ...

    def simple_hull(self) -> BasicMap: ...

    def unshifted_simple_hull(self) -> BasicMap: ...

    def plain_unshifted_simple_hull(self) -> BasicMap: ...

    def unshifted_simple_hull_from_map_list(self, list: MapList) -> BasicMap: ...

    def lower_bound_multi_pw_aff(self, lower: MultiPwAff) -> Map: ...

    def upper_bound_multi_pw_aff(self, upper: MultiPwAff) -> Map: ...

    def floordiv_val(self, d: Val | int) -> Map: ...

    def lexmax_pw_multi_aff(self) -> PwMultiAff: ...

    def min_multi_pw_aff(self) -> MultiPwAff: ...

    def max_multi_pw_aff(self) -> MultiPwAff: ...

    def domain_reverse(self) -> Map: ...

    def range_reverse(self) -> Map: ...

    def union_disjoint(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def intersect_domain_factor_domain(self, factor: Map | BasicMap) -> Map: ...

    @overload
    def intersect_domain_factor_domain(self, factor: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def intersect_domain_factor_range(self, factor: Map | BasicMap) -> Map: ...

    @overload
    def intersect_domain_factor_range(self, factor: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def intersect_range_factor_domain(self, factor: Map | BasicMap) -> Map: ...

    @overload
    def intersect_range_factor_domain(self, factor: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def intersect_range_factor_range(self, factor: Map | BasicMap) -> Map: ...

    @overload
    def intersect_range_factor_range(self, factor: UnionMap | BasicMap | Map) -> UnionMap: ...

    def intersect_domain_wrapped_domain(self, domain: Set | BasicSet) -> Map: ...

    def intersect_range_wrapped_domain(self, domain: Set | BasicSet) -> Map: ...

    def preimage_domain_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> Map: ...

    def preimage_range_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> Map: ...

    def preimage_domain_multi_pw_aff(self, mpa: MultiPwAff) -> Map: ...

    @overload
    def flat_domain_product(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def flat_domain_product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def domain_is_wrapping(self) -> bool: ...

    def range_is_wrapping(self) -> bool: ...

    def is_product(self) -> bool: ...

    def factor_domain(self) -> Map: ...

    def factor_range(self) -> Map: ...

    def domain_factor_domain(self) -> Map: ...

    def domain_factor_range(self) -> Map: ...

    def range_factor_domain(self) -> Map: ...

    def range_factor_range(self) -> Map: ...

    @overload
    def subtract(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def subtract(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def subtract_domain(self, dom: Set | BasicSet) -> Map: ...

    @overload
    def subtract_domain(self, dom: UnionSet | BasicSet | Set) -> UnionMap: ...

    @overload
    def subtract_range(self, dom: Set | BasicSet) -> Map: ...

    @overload
    def subtract_range(self, dom: UnionSet | BasicSet | Set) -> UnionMap: ...

    def complement(self) -> Map: ...

    def fix_input_si(self, input: int, value: int) -> Map: ...

    def lower_bound_val(self, type: dim_type, pos: int, value: Val | int) -> Map: ...

    def upper_bound_val(self, type: dim_type, pos: int, value: Val | int) -> Map: ...

    def convex_hull(self) -> BasicMap: ...

    def polyhedral_hull(self) -> BasicMap: ...

    def project_out_param_id(self, id: Id) -> Map: ...

    def project_out_param_id_list(self, list: IdList) -> Map: ...

    def project_out_all_params(self) -> Map: ...

    def remove_unknown_divs(self) -> Map: ...

    def remove_inputs(self, first: int, n: int) -> Map: ...

    def order_le(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> Map: ...

    def oppose(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> Map: ...

    def order_lt(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> Map: ...

    def params(self) -> Set: ...

    def bind_domain(self, tuple: MultiId) -> Set: ...

    def bind_range(self, tuple: MultiId) -> Set: ...

    def plain_is_single_valued(self) -> bool: ...

    def plain_is_injective(self) -> bool: ...

    def is_injective(self) -> bool: ...

    def is_bijective(self) -> bool: ...

    def is_identity(self) -> bool: ...

    def is_translation(self) -> bool: ...

    def has_equal_space(self, map2: Map | BasicMap) -> bool: ...

    def can_range_curry(self) -> bool: ...

    def range_curry(self) -> Map: ...

    def make_disjoint(self) -> Map: ...

    def align_divs(self) -> Map: ...

    @overload
    def gist_range(self, context: Set | BasicSet) -> Map: ...

    @overload
    def gist_range(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def gist_params(self, context: Set | BasicSet) -> Map: ...

    def gist_basic_map(self, context: BasicMap) -> Map: ...

    def get_range_stride_info(self, pos: int) -> StrideInfo: ...

    def get_range_lattice_tile(self) -> FixedBox: ...

    def get_range_simple_fixed_box_hull(self) -> FixedBox: ...

    def coalesce(self) -> Map: ...

    def plain_is_equal(self, map2: Map | BasicMap) -> bool: ...

    def n_basic_map(self) -> int: ...

    def foreach_basic_map(self, fn: Callable[[BasicMap], None]) -> None: ...

    def get_basic_map_list(self) -> BasicMapList: ...

    def fixed_power_val(self, exp: Val | int) -> Map: ...

    def power(self) -> tuple[Map, bool]: ...

    def reaching_path_lengths(self) -> tuple[Map, bool]: ...

    def transitive_closure(self) -> tuple[Map, bool]: ...

    def lex_le_map(self, map2: Map | BasicMap) -> Map: ...

    def lex_lt_map(self, map2: Map | BasicMap) -> Map: ...

    def lex_ge_map(self, map2: Map | BasicMap) -> Map: ...

    def lex_gt_map(self, map2: Map | BasicMap) -> Map: ...

    def eq_at_multi_pw_aff(self, mpa: MultiPwAff) -> Map: ...

    def lex_lt_at_multi_pw_aff(self, mpa: MultiPwAff) -> Map: ...

    def lex_le_at_multi_pw_aff(self, mpa: MultiPwAff) -> Map: ...

    def lex_gt_at_multi_pw_aff(self, mpa: MultiPwAff) -> Map: ...

    def lex_ge_at_multi_pw_aff(self, mpa: MultiPwAff) -> Map: ...

    def dim_min(self, pos: int) -> PwAff: ...

    def dim_max(self, pos: int) -> PwAff: ...

    def as_pw_multi_aff(self) -> PwMultiAff: ...

    def apply_pw_qpolynomial_fold(self, pwf: PwQPolynomialFold) -> tuple[PwQPolynomialFold, bool]: ...

    def to_union_map(self) -> UnionMap: ...

    def as_union_pw_multi_aff(self) -> UnionPwMultiAff: ...

    def as_multi_union_pw_aff(self) -> MultiUnionPwAff: ...

    def apply_union_pw_qpolynomial_fold(self, upwf: UnionPwQPolynomialFold) -> tuple[UnionPwQPolynomialFold, bool]: ...

    def domain_map_union_pw_multi_aff(self) -> UnionPwMultiAff: ...

    def add_map(self, map: Map | BasicMap) -> UnionMap: ...

    def intersect_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def intersect_domain_space(self, space: Space) -> UnionMap: ...

    def intersect_range_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def intersect_range_space(self, space: Space) -> UnionMap: ...

    def intersect_domain_wrapped_domain_union_set(self, domain: UnionSet | BasicSet | Set) -> UnionMap: ...

    def intersect_range_wrapped_domain_union_set(self, domain: UnionSet | BasicSet | Set) -> UnionMap: ...

    def preimage_domain_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionMap: ...

    def preimage_range_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionMap: ...

    def n_map(self) -> int: ...

    def foreach_map(self, fn: Callable[[Map], None]) -> None: ...

    def get_map_list(self) -> MapList: ...

    def every_map(self, test: Callable[[Map], bool]) -> bool: ...

    def remove_map_if(self, fn: Callable[[Map], bool]) -> UnionMap: ...

    def contains(self, space: Space) -> bool: ...

    def extract_map(self, space: Space) -> Map: ...

    def isa_map(self) -> bool: ...

    def as_map(self) -> Map: ...

    def lex_lt_union_map(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def lex_le_union_map(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def lex_gt_union_map(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def lex_ge_union_map(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def eq_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def lex_le_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def lex_lt_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def lex_ge_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def lex_gt_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def compute_flow(self, must_source: UnionMap | BasicMap | Map, may_source: UnionMap | BasicMap | Map, schedule: UnionMap | BasicMap | Map) -> tuple[UnionMap, UnionMap, UnionMap, UnionMap]: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    __lt__ = islpy._monkeypatch.map_lt

    __le__ = islpy._monkeypatch.map_le

    __gt__ = islpy._monkeypatch.map_gt

    __ge__ = islpy._monkeypatch.map_ge

    project_out_except = islpy._monkeypatch.obj_project_out_except

    add_constraints = islpy._monkeypatch.obj_add_constraints

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

    __and__ = islpy._monkeypatch.bmap_and

    __rand__ = islpy._monkeypatch.bmap_and

    __or__ = islpy._monkeypatch.map_or

    __ror__ = islpy._monkeypatch.map_or

    __sub__ = islpy._monkeypatch.map_sub

    get_constraints = islpy._monkeypatch.basic_obj_get_constraints

class Set:
    @overload
    def __init__(self, arg: BasicSet, /) -> None: ...

    @overload
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def n_dim(self) -> int: ...

    def n_param(self) -> int: ...

    def tuple_dim(self) -> int: ...

    def dim(self, type: dim_type) -> int: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def reset_space(self, space: Space) -> Set: ...

    def has_tuple_name(self) -> bool: ...

    def get_tuple_name(self) -> str: ...

    def set_tuple_name(self, s: str) -> Set: ...

    def has_dim_name(self, type: dim_type, pos: int) -> bool: ...

    def get_dim_name(self, type: dim_type, pos: int) -> str | None: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> Set: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> Set: ...

    def has_dim_id(self, type: dim_type, pos: int) -> bool: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def set_tuple_id(self, id: Id) -> Set: ...

    def reset_tuple_id(self) -> Set: ...

    def has_tuple_id(self) -> bool: ...

    def get_tuple_id(self) -> Id: ...

    def reset_user(self) -> Set: ...

    def find_dim_by_id(self, type: dim_type, id: Id) -> int: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def remove_redundancies(self) -> Set: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> Set: ...

    def dump(self) -> None: ...

    def lower_bound_val(self, type: dim_type, pos: int, value: Val | int) -> Set: ...

    def upper_bound_val(self, type: dim_type, pos: int, value: Val | int) -> Set: ...

    def lower_bound_multi_val(self, lower: MultiVal) -> Set: ...

    def upper_bound_multi_val(self, upper: MultiVal) -> Set: ...

    def lower_bound_multi_pw_aff(self, lower: MultiPwAff) -> Set: ...

    def upper_bound_multi_pw_aff(self, upper: MultiPwAff) -> Set: ...

    def equate(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> Set: ...

    def partial_lexmin(self, dom: Set | BasicSet) -> tuple[Set, Set]: ...

    def partial_lexmax(self, dom: Set | BasicSet) -> tuple[Set, Set]: ...

    def lexmin(self) -> Set: ...

    def lexmax(self) -> Set: ...

    def lexmin_pw_multi_aff(self) -> PwMultiAff: ...

    def lexmax_pw_multi_aff(self) -> PwMultiAff: ...

    def min_multi_pw_aff(self) -> MultiPwAff: ...

    def max_multi_pw_aff(self) -> MultiPwAff: ...

    def follows_at(self, set2: Set | BasicSet, pos: int) -> int: ...

    def params(self) -> Set: ...

    def from_params(self) -> Set: ...

    def bind(self, tuple: MultiId) -> Set: ...

    def unbind_params(self, tuple: MultiId) -> Set: ...

    def unbind_params_insert_domain(self, domain: MultiId) -> Map: ...

    @staticmethod
    def empty(space: Space) -> Set: ...

    @staticmethod
    def universe(space: Space) -> Set: ...

    @staticmethod
    def nat_universe(space: Space) -> Set: ...

    def copy(self) -> Set: ...

    @staticmethod
    def from_basic_set(bset: BasicSet) -> Set: ...

    def sample(self) -> BasicSet: ...

    def sample_point(self) -> Point: ...

    def detect_equalities(self) -> Set: ...

    def affine_hull(self) -> BasicSet: ...

    def convex_hull(self) -> BasicSet: ...

    def polyhedral_hull(self) -> BasicSet: ...

    def simple_hull(self) -> BasicSet: ...

    def unshifted_simple_hull(self) -> BasicSet: ...

    def plain_unshifted_simple_hull(self) -> BasicSet: ...

    def unshifted_simple_hull_from_set_list(self, list: SetList) -> BasicSet: ...

    def bounded_simple_hull(self) -> BasicSet: ...

    def wrapped_reverse(self) -> Set: ...

    def union_disjoint(self, set2: Set | BasicSet) -> Set: ...

    @overload
    def union(self, set2: Set | BasicSet) -> Set: ...

    @overload
    def union(self, uset2: UnionSet | BasicSet | Set) -> UnionSet: ...

    @overload
    def product(self, set2: Set | BasicSet) -> Set: ...

    @overload
    def product(self, uset2: UnionSet | BasicSet | Set) -> UnionSet: ...

    def flat_product(self, set2: Set | BasicSet) -> Set: ...

    @overload
    def intersect(self, set2: Set | BasicSet) -> Set: ...

    @overload
    def intersect(self, uset2: UnionSet | BasicSet | Set) -> UnionSet: ...

    def intersect_params(self, params: Set | BasicSet) -> Set: ...

    def intersect_factor_domain(self, domain: Set | BasicSet) -> Set: ...

    def intersect_factor_range(self, range: Set | BasicSet) -> Set: ...

    @overload
    def subtract(self, set2: Set | BasicSet) -> Set: ...

    @overload
    def subtract(self, uset2: UnionSet | BasicSet | Set) -> UnionSet: ...

    def complement(self) -> Set: ...

    @overload
    def apply(self, map: Map | BasicMap) -> Set: ...

    @overload
    def apply(self, umap: UnionMap | BasicMap | Map) -> UnionSet: ...

    def preimage_multi_aff(self, ma: MultiAff) -> Set: ...

    def preimage_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> Set: ...

    def preimage_multi_pw_aff(self, mpa: MultiPwAff) -> Set: ...

    def fix_val(self, type: dim_type, pos: int, v: Val | int) -> Set: ...

    def fix_dim_si(self, dim: int, value: int) -> Set: ...

    def insert_dims(self, type: dim_type, pos: int, n: int) -> Set: ...

    def add_dims(self, type: dim_type, n: int) -> Set: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> Set: ...

    def project_out_param_id(self, id: Id) -> Set: ...

    def project_out_param_id_list(self, list: IdList) -> Set: ...

    def project_out(self, type: dim_type, first: int, n: int) -> Set: ...

    def project_out_all_params(self) -> Set: ...

    def project_onto_map(self, type: dim_type, first: int, n: int) -> Map: ...

    def eliminate(self, type: dim_type, first: int, n: int) -> Set: ...

    def eliminate_dims(self, first: int, n: int) -> Set: ...

    def remove_dims(self, type: dim_type, first: int, n: int) -> Set: ...

    def remove_divs_involving_dims(self, type: dim_type, first: int, n: int) -> Set: ...

    def remove_unknown_divs(self) -> Set: ...

    def remove_divs(self) -> Set: ...

    def split_dims(self, type: dim_type, first: int, n: int) -> Set: ...

    def drop_constraints_involving_dims(self, type: dim_type, first: int, n: int) -> Set: ...

    def drop_constraints_not_involving_dims(self, type: dim_type, first: int, n: int) -> Set: ...

    def involves_locals(self) -> bool: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def plain_is_empty(self) -> bool: ...

    def plain_is_universe(self) -> bool: ...

    def is_params(self) -> bool: ...

    def is_empty(self) -> bool: ...

    def is_bounded(self) -> bool: ...

    @overload
    def is_subset(self, set2: Set | BasicSet) -> bool: ...

    @overload
    def is_subset(self, uset2: UnionSet | BasicSet | Set) -> bool: ...

    @overload
    def is_strict_subset(self, set2: Set | BasicSet) -> bool: ...

    @overload
    def is_strict_subset(self, uset2: UnionSet | BasicSet | Set) -> bool: ...

    @overload
    def is_equal(self, set2: Set | BasicSet) -> bool: ...

    @overload
    def is_equal(self, uset2: UnionSet | BasicSet | Set) -> bool: ...

    @overload
    def is_disjoint(self, set2: Set | BasicSet) -> bool: ...

    @overload
    def is_disjoint(self, uset2: UnionSet | BasicSet | Set) -> bool: ...

    def is_singleton(self) -> bool: ...

    def is_box(self) -> bool: ...

    def has_equal_space(self, set2: Set | BasicSet) -> bool: ...

    def sum(self, set2: Set | BasicSet) -> Set: ...

    def neg(self) -> Set: ...

    def make_disjoint(self) -> Set: ...

    def compute_divs(self) -> Set: ...

    def align_divs(self) -> Set: ...

    def get_plain_multi_val_if_fixed(self) -> MultiVal: ...

    def plain_get_val_if_fixed(self, type: dim_type, pos: int) -> Val: ...

    def dim_is_bounded(self, type: dim_type, pos: int) -> bool: ...

    def dim_has_lower_bound(self, type: dim_type, pos: int) -> bool: ...

    def dim_has_upper_bound(self, type: dim_type, pos: int) -> bool: ...

    def dim_has_any_lower_bound(self, type: dim_type, pos: int) -> bool: ...

    def dim_has_any_upper_bound(self, type: dim_type, pos: int) -> bool: ...

    def gist_basic_set(self, context: BasicSet) -> Set: ...

    @overload
    def gist(self, context: Set | BasicSet) -> Set: ...

    @overload
    def gist(self, context: UnionSet | BasicSet | Set) -> UnionSet: ...

    def gist_params(self, context: Set | BasicSet) -> Set: ...

    def dim_residue_class_val(self, pos: int) -> tuple[Val, Val]: ...

    def get_stride_info(self, pos: int) -> StrideInfo: ...

    def get_stride(self, pos: int) -> Val: ...

    def get_lattice_tile(self) -> FixedBox: ...

    def get_simple_fixed_box_hull(self) -> FixedBox: ...

    def coalesce(self) -> Set: ...

    def plain_cmp(self, set2: Set | BasicSet) -> int: ...

    def plain_is_equal(self, set2: Set | BasicSet) -> bool: ...

    def plain_is_disjoint(self, set2: Set | BasicSet) -> bool: ...

    def __hash__(self) -> int: ...

    def n_basic_set(self) -> int: ...

    def foreach_basic_set(self, fn: Callable[[BasicSet], None]) -> None: ...

    def get_basic_set_list(self) -> BasicSetList: ...

    def foreach_point(self, fn: Callable[[Point], None]) -> None: ...

    def count_val(self) -> Val: ...

    @staticmethod
    def from_point(pnt: Point) -> Set: ...

    @staticmethod
    def box_from_points(pnt1: Point, pnt2: Point) -> Set: ...

    def lift(self) -> Set: ...

    def lex_le_set(self, set2: Set | BasicSet) -> Map: ...

    def lex_lt_set(self, set2: Set | BasicSet) -> Map: ...

    def lex_ge_set(self, set2: Set | BasicSet) -> Map: ...

    def lex_gt_set(self, set2: Set | BasicSet) -> Map: ...

    def __len__(self) -> int: ...

    def align_params(self, model: Space) -> Set: ...

    def drop_unused_params(self) -> Set: ...

    @staticmethod
    def from_multi_aff(ma: MultiAff) -> Set: ...

    def coefficients(self) -> BasicSet: ...

    def solutions(self) -> BasicSet: ...

    def dim_max(self, pos: int) -> PwAff: ...

    def dim_min(self, pos: int) -> PwAff: ...

    def to_str(self) -> str: ...

    def translation(self) -> Map: ...

    def identity(self) -> Map: ...

    def is_wrapping(self) -> bool: ...

    def unwrap(self) -> Map: ...

    def flatten(self) -> Set: ...

    def flatten_map(self) -> Map: ...

    def insert_domain(self, domain: Space) -> Map: ...

    def wrapped_domain_map(self) -> Map: ...

    def to_list(self) -> SetList: ...

    def pw_aff_on_domain_val(self, v: Val | int) -> PwAff: ...

    def param_pw_aff_on_domain_id(self, id: Id) -> PwAff: ...

    def indicator_function(self) -> PwAff: ...

    @staticmethod
    def from_pw_aff(pwaff: PwAff | Aff) -> Set: ...

    def pw_multi_aff_on_domain_multi_val(self, mv: MultiVal) -> PwMultiAff: ...

    @staticmethod
    def from_pw_multi_aff(pma: PwMultiAff | MultiAff) -> Set: ...

    def as_pw_multi_aff(self) -> PwMultiAff: ...

    @staticmethod
    def from_multi_pw_aff(mpa: MultiPwAff) -> Set: ...

    def apply_pw_qpolynomial_fold(self, pwf: PwQPolynomialFold) -> tuple[PwQPolynomialFold, bool]: ...

    def to_union_set(self) -> UnionSet: ...

    @staticmethod
    def from_union_set(uset: UnionSet | BasicSet | Set) -> Set: ...

    def add_constraint(self, constraint: Constraint) -> Set: ...

    def min_val(self, obj: Aff) -> Val: ...

    def max_val(self, obj: Aff) -> Val: ...

    def dim_min_val(self, pos: int) -> Val: ...

    def dim_max_val(self, pos: int) -> Val: ...

    def identity_union_pw_multi_aff(self) -> UnionPwMultiAff: ...

    def apply_union_pw_qpolynomial_fold(self, upwf: UnionPwQPolynomialFold) -> tuple[UnionPwQPolynomialFold, bool]: ...

    def add_set(self, set: Set | BasicSet) -> UnionSet: ...

    def preimage_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionSet: ...

    def n_set(self) -> int: ...

    def foreach_set(self, fn: Callable[[Set], None]) -> None: ...

    def every_set(self, test: Callable[[Set], bool]) -> bool: ...

    def get_set_list(self) -> SetList: ...

    def contains(self, space: Space) -> bool: ...

    def extract_set(self, space: Space) -> Set: ...

    def isa_set(self) -> bool: ...

    def as_set(self) -> Set: ...

    def lex_lt_union_set(self, uset2: UnionSet | BasicSet | Set) -> UnionMap: ...

    def lex_le_union_set(self, uset2: UnionSet | BasicSet | Set) -> UnionMap: ...

    def lex_gt_union_set(self, uset2: UnionSet | BasicSet | Set) -> UnionMap: ...

    def lex_ge_union_set(self, uset2: UnionSet | BasicSet | Set) -> UnionMap: ...

    def compute_schedule(self, validity: UnionMap | BasicMap | Map, proximity: UnionMap | BasicMap | Map) -> Schedule: ...

    def min_multi_union_pw_aff(self, obj: MultiUnionPwAff) -> MultiVal: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    __lt__ = islpy._monkeypatch.set_lt

    __le__ = islpy._monkeypatch.set_le

    __gt__ = islpy._monkeypatch.set_gt

    __ge__ = islpy._monkeypatch.set_ge

    project_out_except = islpy._monkeypatch.obj_project_out_except

    add_constraints = islpy._monkeypatch.obj_add_constraints

    eliminate_except = islpy._monkeypatch.obj_eliminate_except

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

    __and__ = islpy._monkeypatch.set_and

    __rand__ = islpy._monkeypatch.set_and

    __or__ = islpy._monkeypatch.set_or

    __ror__ = islpy._monkeypatch.set_or

    __sub__ = islpy._monkeypatch.set_sub

    get_basic_sets = islpy._monkeypatch.set_get_basic_sets

class Map:
    @overload
    def __init__(self, arg: BasicMap, /) -> None: ...

    @overload
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def domain_tuple_dim(self) -> int: ...

    def range_tuple_dim(self) -> int: ...

    def dim(self, type: dim_type) -> int: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def has_tuple_name(self, type: dim_type) -> bool: ...

    def get_tuple_name(self, type: dim_type) -> str: ...

    def set_tuple_name(self, type: dim_type, s: str) -> Map: ...

    def has_dim_name(self, type: dim_type, pos: int) -> bool: ...

    def get_dim_name(self, type: dim_type, pos: int) -> str | None: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> Map: ...

    def set_dim_id(self, type: dim_type, pos: int, id: Id) -> Map: ...

    def has_dim_id(self, type: dim_type, pos: int) -> bool: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    def set_domain_tuple_id(self, id: Id) -> Map: ...

    def set_range_tuple_id(self, id: Id) -> Map: ...

    def set_tuple_id(self, type: dim_type, id: Id) -> Map: ...

    def reset_tuple_id(self, type: dim_type) -> Map: ...

    def has_domain_tuple_id(self) -> bool: ...

    def has_range_tuple_id(self) -> bool: ...

    def has_tuple_id(self, type: dim_type) -> bool: ...

    def get_domain_tuple_id(self) -> Id: ...

    def get_range_tuple_id(self) -> Id: ...

    def get_tuple_id(self, type: dim_type) -> Id: ...

    def reset_user(self) -> Map: ...

    def find_dim_by_id(self, type: dim_type, id: Id) -> int: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def remove_redundancies(self) -> Map: ...

    def simple_hull(self) -> BasicMap: ...

    def unshifted_simple_hull(self) -> BasicMap: ...

    def plain_unshifted_simple_hull(self) -> BasicMap: ...

    def unshifted_simple_hull_from_map_list(self, list: MapList) -> BasicMap: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> Map: ...

    def dump(self) -> None: ...

    def to_str(self) -> str: ...

    def lower_bound_multi_pw_aff(self, lower: MultiPwAff) -> Map: ...

    def upper_bound_multi_pw_aff(self, upper: MultiPwAff) -> Map: ...

    def sum(self, map2: Map | BasicMap) -> Map: ...

    def neg(self) -> Map: ...

    def floordiv_val(self, d: Val | int) -> Map: ...

    def partial_lexmax(self, dom: Set | BasicSet) -> tuple[Map, Set]: ...

    def partial_lexmin(self, dom: Set | BasicSet) -> tuple[Map, Set]: ...

    def lexmin(self) -> Map: ...

    def lexmax(self) -> Map: ...

    def lexmin_pw_multi_aff(self) -> PwMultiAff: ...

    def lexmax_pw_multi_aff(self) -> PwMultiAff: ...

    def min_multi_pw_aff(self) -> MultiPwAff: ...

    def max_multi_pw_aff(self) -> MultiPwAff: ...

    @staticmethod
    def universe(space: Space) -> Map: ...

    @staticmethod
    def nat_universe(space: Space) -> Map: ...

    @staticmethod
    def empty(space: Space) -> Map: ...

    @staticmethod
    def identity(space: Space) -> Map: ...

    @staticmethod
    def lex_lt_first(space: Space, n: int) -> Map: ...

    @staticmethod
    def lex_le_first(space: Space, n: int) -> Map: ...

    @staticmethod
    def lex_lt(set_space: Space) -> Map: ...

    @staticmethod
    def lex_le(set_space: Space) -> Map: ...

    @staticmethod
    def lex_gt_first(space: Space, n: int) -> Map: ...

    @staticmethod
    def lex_ge_first(space: Space, n: int) -> Map: ...

    @staticmethod
    def lex_gt(set_space: Space) -> Map: ...

    @staticmethod
    def lex_ge(set_space: Space) -> Map: ...

    def copy(self) -> Map: ...

    def reverse(self) -> Map: ...

    def domain_reverse(self) -> Map: ...

    def range_reverse(self) -> Map: ...

    @overload
    def union(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def union(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def union_disjoint(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def intersect_domain(self, set: Set | BasicSet) -> Map: ...

    @overload
    def intersect_domain(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    @overload
    def intersect_range(self, set: Set | BasicSet) -> Map: ...

    @overload
    def intersect_range(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    @overload
    def intersect_domain_factor_domain(self, factor: Map | BasicMap) -> Map: ...

    @overload
    def intersect_domain_factor_domain(self, factor: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def intersect_domain_factor_range(self, factor: Map | BasicMap) -> Map: ...

    @overload
    def intersect_domain_factor_range(self, factor: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def intersect_range_factor_domain(self, factor: Map | BasicMap) -> Map: ...

    @overload
    def intersect_range_factor_domain(self, factor: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def intersect_range_factor_range(self, factor: Map | BasicMap) -> Map: ...

    @overload
    def intersect_range_factor_range(self, factor: UnionMap | BasicMap | Map) -> UnionMap: ...

    def intersect_domain_wrapped_domain(self, domain: Set | BasicSet) -> Map: ...

    def intersect_range_wrapped_domain(self, domain: Set | BasicSet) -> Map: ...

    @overload
    def apply_domain(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def apply_domain(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def apply_range(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def apply_range(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def preimage_domain_multi_aff(self, ma: MultiAff) -> Map: ...

    def preimage_range_multi_aff(self, ma: MultiAff) -> Map: ...

    def preimage_domain_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> Map: ...

    def preimage_range_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> Map: ...

    def preimage_domain_multi_pw_aff(self, mpa: MultiPwAff) -> Map: ...

    @overload
    def product(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def domain_product(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def domain_product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def range_product(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def range_product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def flat_product(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def flat_domain_product(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def flat_domain_product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def flat_range_product(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def flat_range_product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def domain_is_wrapping(self) -> bool: ...

    def range_is_wrapping(self) -> bool: ...

    def is_product(self) -> bool: ...

    def factor_domain(self) -> Map: ...

    def factor_range(self) -> Map: ...

    def domain_factor_domain(self) -> Map: ...

    def domain_factor_range(self) -> Map: ...

    def range_factor_domain(self) -> Map: ...

    def range_factor_range(self) -> Map: ...

    @overload
    def intersect(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def intersect(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def intersect_params(self, params: Set | BasicSet) -> Map: ...

    @overload
    def subtract(self, map2: Map | BasicMap) -> Map: ...

    @overload
    def subtract(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def subtract_domain(self, dom: Set | BasicSet) -> Map: ...

    @overload
    def subtract_domain(self, dom: UnionSet | BasicSet | Set) -> UnionMap: ...

    @overload
    def subtract_range(self, dom: Set | BasicSet) -> Map: ...

    @overload
    def subtract_range(self, dom: UnionSet | BasicSet | Set) -> UnionMap: ...

    def complement(self) -> Map: ...

    def fix_input_si(self, input: int, value: int) -> Map: ...

    def fix_val(self, type: dim_type, pos: int, v: Val | int) -> Map: ...

    def lower_bound_val(self, type: dim_type, pos: int, value: Val | int) -> Map: ...

    def upper_bound_val(self, type: dim_type, pos: int, value: Val | int) -> Map: ...

    def deltas(self) -> Set: ...

    def deltas_map(self) -> Map: ...

    def detect_equalities(self) -> Map: ...

    def affine_hull(self) -> BasicMap: ...

    def convex_hull(self) -> BasicMap: ...

    def polyhedral_hull(self) -> BasicMap: ...

    def add_dims(self, type: dim_type, n: int) -> Map: ...

    def insert_dims(self, type: dim_type, pos: int, n: int) -> Map: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> Map: ...

    def project_out_param_id(self, id: Id) -> Map: ...

    def project_out_param_id_list(self, list: IdList) -> Map: ...

    def project_out(self, type: dim_type, first: int, n: int) -> Map: ...

    def project_out_all_params(self) -> Map: ...

    def remove_unknown_divs(self) -> Map: ...

    def remove_divs(self) -> Map: ...

    def eliminate(self, type: dim_type, first: int, n: int) -> Map: ...

    def remove_dims(self, type: dim_type, first: int, n: int) -> Map: ...

    def remove_divs_involving_dims(self, type: dim_type, first: int, n: int) -> Map: ...

    def remove_inputs(self, first: int, n: int) -> Map: ...

    def order_ge(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> Map: ...

    def order_le(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> Map: ...

    def equate(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> Map: ...

    def oppose(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> Map: ...

    def order_lt(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> Map: ...

    def order_gt(self, type1: dim_type, pos1: int, type2: dim_type, pos2: int) -> Map: ...

    def wrap(self) -> Set: ...

    def flatten(self) -> Map: ...

    def flatten_domain(self) -> Map: ...

    def flatten_range(self) -> Map: ...

    def params(self) -> Set: ...

    def domain(self) -> Set: ...

    def range(self) -> Set: ...

    def domain_map(self) -> Map: ...

    def range_map(self) -> Map: ...

    @staticmethod
    def from_basic_map(bmap: BasicMap) -> Map: ...

    @staticmethod
    def from_domain(set: Set | BasicSet) -> Map: ...

    @staticmethod
    def from_range(set: Set | BasicSet) -> Map: ...

    @staticmethod
    def from_domain_and_range(domain: Set | BasicSet, range: Set | BasicSet) -> Map: ...

    def sample(self) -> BasicMap: ...

    def bind_domain(self, tuple: MultiId) -> Set: ...

    def bind_range(self, tuple: MultiId) -> Set: ...

    def plain_is_empty(self) -> bool: ...

    def plain_is_universe(self) -> bool: ...

    def is_empty(self) -> bool: ...

    @overload
    def is_subset(self, map2: Map | BasicMap) -> bool: ...

    @overload
    def is_subset(self, umap2: UnionMap | BasicMap | Map) -> bool: ...

    @overload
    def is_strict_subset(self, map2: Map | BasicMap) -> bool: ...

    @overload
    def is_strict_subset(self, umap2: UnionMap | BasicMap | Map) -> bool: ...

    @overload
    def is_equal(self, map2: Map | BasicMap) -> bool: ...

    @overload
    def is_equal(self, umap2: UnionMap | BasicMap | Map) -> bool: ...

    @overload
    def is_disjoint(self, map2: Map | BasicMap) -> bool: ...

    @overload
    def is_disjoint(self, umap2: UnionMap | BasicMap | Map) -> bool: ...

    def plain_is_single_valued(self) -> bool: ...

    def is_single_valued(self) -> bool: ...

    def plain_is_injective(self) -> bool: ...

    def is_injective(self) -> bool: ...

    def is_bijective(self) -> bool: ...

    def is_identity(self) -> bool: ...

    def is_translation(self) -> bool: ...

    def has_equal_space(self, map2: Map | BasicMap) -> bool: ...

    def can_zip(self) -> bool: ...

    def zip(self) -> Map: ...

    def can_curry(self) -> bool: ...

    def curry(self) -> Map: ...

    def can_range_curry(self) -> bool: ...

    def range_curry(self) -> Map: ...

    def can_uncurry(self) -> bool: ...

    def uncurry(self) -> Map: ...

    def make_disjoint(self) -> Map: ...

    def compute_divs(self) -> Map: ...

    def align_divs(self) -> Map: ...

    def drop_constraints_involving_dims(self, type: dim_type, first: int, n: int) -> Map: ...

    def drop_constraints_not_involving_dims(self, type: dim_type, first: int, n: int) -> Map: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def plain_get_val_if_fixed(self, type: dim_type, pos: int) -> Val: ...

    @overload
    def gist(self, context: Map | BasicMap) -> Map: ...

    @overload
    def gist(self, context: UnionMap | BasicMap | Map) -> UnionMap: ...

    @overload
    def gist_domain(self, context: Set | BasicSet) -> Map: ...

    @overload
    def gist_domain(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    @overload
    def gist_range(self, context: Set | BasicSet) -> Map: ...

    @overload
    def gist_range(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def gist_params(self, context: Set | BasicSet) -> Map: ...

    def gist_basic_map(self, context: BasicMap) -> Map: ...

    def get_range_stride_info(self, pos: int) -> StrideInfo: ...

    def get_range_lattice_tile(self) -> FixedBox: ...

    def get_range_simple_fixed_box_hull(self) -> FixedBox: ...

    def coalesce(self) -> Map: ...

    def plain_is_equal(self, map2: Map | BasicMap) -> bool: ...

    def __hash__(self) -> int: ...

    def n_basic_map(self) -> int: ...

    def foreach_basic_map(self, fn: Callable[[BasicMap], None]) -> None: ...

    def get_basic_map_list(self) -> BasicMapList: ...

    def fixed_power_val(self, exp: Val | int) -> Map: ...

    def power(self) -> tuple[Map, bool]: ...

    def reaching_path_lengths(self) -> tuple[Map, bool]: ...

    def transitive_closure(self) -> tuple[Map, bool]: ...

    def lex_le_map(self, map2: Map | BasicMap) -> Map: ...

    def lex_lt_map(self, map2: Map | BasicMap) -> Map: ...

    def lex_ge_map(self, map2: Map | BasicMap) -> Map: ...

    def lex_gt_map(self, map2: Map | BasicMap) -> Map: ...

    def eq_at_multi_pw_aff(self, mpa: MultiPwAff) -> Map: ...

    def lex_lt_at_multi_pw_aff(self, mpa: MultiPwAff) -> Map: ...

    def lex_le_at_multi_pw_aff(self, mpa: MultiPwAff) -> Map: ...

    def lex_gt_at_multi_pw_aff(self, mpa: MultiPwAff) -> Map: ...

    def lex_ge_at_multi_pw_aff(self, mpa: MultiPwAff) -> Map: ...

    def align_params(self, model: Space) -> Map: ...

    def drop_unused_params(self) -> Map: ...

    @staticmethod
    def from_aff(aff: Aff) -> Map: ...

    @staticmethod
    def from_multi_aff(maff: MultiAff) -> Map: ...

    def dim_min(self, pos: int) -> PwAff: ...

    def dim_max(self, pos: int) -> PwAff: ...

    def to_list(self) -> MapList: ...

    @staticmethod
    def from_pw_aff(pwaff: PwAff | Aff) -> Map: ...

    @staticmethod
    def from_pw_multi_aff(pma: PwMultiAff | MultiAff) -> Map: ...

    def as_pw_multi_aff(self) -> PwMultiAff: ...

    @staticmethod
    def from_multi_pw_aff(mpa: MultiPwAff) -> Map: ...

    def apply_pw_qpolynomial_fold(self, pwf: PwQPolynomialFold) -> tuple[PwQPolynomialFold, bool]: ...

    def to_union_map(self) -> UnionMap: ...

    @staticmethod
    def from_union_map(umap: UnionMap | BasicMap | Map) -> Map: ...

    def add_constraint(self, constraint: Constraint) -> Map: ...

    def as_union_pw_multi_aff(self) -> UnionPwMultiAff: ...

    def as_multi_union_pw_aff(self) -> MultiUnionPwAff: ...

    def apply_union_pw_qpolynomial_fold(self, upwf: UnionPwQPolynomialFold) -> tuple[UnionPwQPolynomialFold, bool]: ...

    def domain_map_union_pw_multi_aff(self) -> UnionPwMultiAff: ...

    def add_map(self, map: Map | BasicMap) -> UnionMap: ...

    def intersect_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def intersect_domain_space(self, space: Space) -> UnionMap: ...

    def intersect_range_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def intersect_range_space(self, space: Space) -> UnionMap: ...

    def intersect_domain_wrapped_domain_union_set(self, domain: UnionSet | BasicSet | Set) -> UnionMap: ...

    def intersect_range_wrapped_domain_union_set(self, domain: UnionSet | BasicSet | Set) -> UnionMap: ...

    def preimage_domain_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionMap: ...

    def preimage_range_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionMap: ...

    def n_map(self) -> int: ...

    def foreach_map(self, fn: Callable[[Map], None]) -> None: ...

    def get_map_list(self) -> MapList: ...

    def every_map(self, test: Callable[[Map], bool]) -> bool: ...

    def remove_map_if(self, fn: Callable[[Map], bool]) -> UnionMap: ...

    def contains(self, space: Space) -> bool: ...

    def extract_map(self, space: Space) -> Map: ...

    def isa_map(self) -> bool: ...

    def as_map(self) -> Map: ...

    def lex_lt_union_map(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def lex_le_union_map(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def lex_gt_union_map(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def lex_ge_union_map(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def eq_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def lex_le_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def lex_lt_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def lex_ge_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def lex_gt_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def compute_flow(self, must_source: UnionMap | BasicMap | Map, may_source: UnionMap | BasicMap | Map, schedule: UnionMap | BasicMap | Map) -> tuple[UnionMap, UnionMap, UnionMap, UnionMap]: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    __lt__ = islpy._monkeypatch.map_lt

    __le__ = islpy._monkeypatch.map_le

    __gt__ = islpy._monkeypatch.map_gt

    __ge__ = islpy._monkeypatch.map_ge

    project_out_except = islpy._monkeypatch.obj_project_out_except

    add_constraints = islpy._monkeypatch.obj_add_constraints

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

    __and__ = islpy._monkeypatch.map_and

    __rand__ = islpy._monkeypatch.map_and

    __or__ = islpy._monkeypatch.map_or

    __ror__ = islpy._monkeypatch.map_or

    __sub__ = islpy._monkeypatch.map_sub

    get_basic_maps = islpy._monkeypatch.map_get_basic_maps

class UnionSet:
    @overload
    def __init__(self, arg: Set, /) -> None: ...

    @overload
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def identity_union_pw_multi_aff(self) -> UnionPwMultiAff: ...

    def apply_union_pw_qpolynomial_fold(self, upwf: UnionPwQPolynomialFold) -> tuple[UnionPwQPolynomialFold, bool]: ...

    def wrapped_domain_map(self) -> UnionMap: ...

    def identity(self) -> UnionMap: ...

    def unwrap(self) -> UnionMap: ...

    def align_params(self, model: Space) -> UnionSet: ...

    def dim(self, type: dim_type) -> int: ...

    @staticmethod
    def from_basic_set(bset: BasicSet) -> UnionSet: ...

    @staticmethod
    def from_set(set: Set | BasicSet) -> UnionSet: ...

    @staticmethod
    def empty_ctx(ctx: Context) -> UnionSet: ...

    @staticmethod
    def empty_space(space: Space) -> UnionSet: ...

    @staticmethod
    def empty(space: Space) -> UnionSet: ...

    def copy(self) -> UnionSet: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def reset_user(self) -> UnionSet: ...

    def universe(self) -> UnionSet: ...

    def params(self) -> Set: ...

    def detect_equalities(self) -> UnionSet: ...

    def affine_hull(self) -> UnionSet: ...

    def polyhedral_hull(self) -> UnionSet: ...

    def remove_redundancies(self) -> UnionSet: ...

    def simple_hull(self) -> UnionSet: ...

    def coalesce(self) -> UnionSet: ...

    def compute_divs(self) -> UnionSet: ...

    def lexmin(self) -> UnionSet: ...

    def lexmax(self) -> UnionSet: ...

    def add_set(self, set: Set | BasicSet) -> UnionSet: ...

    def union(self, uset2: UnionSet | BasicSet | Set) -> UnionSet: ...

    def subtract(self, uset2: UnionSet | BasicSet | Set) -> UnionSet: ...

    def intersect(self, uset2: UnionSet | BasicSet | Set) -> UnionSet: ...

    def intersect_params(self, set: Set | BasicSet) -> UnionSet: ...

    def product(self, uset2: UnionSet | BasicSet | Set) -> UnionSet: ...

    def gist(self, context: UnionSet | BasicSet | Set) -> UnionSet: ...

    def gist_params(self, set: Set | BasicSet) -> UnionSet: ...

    def apply(self, umap: UnionMap | BasicMap | Map) -> UnionSet: ...

    def preimage_multi_aff(self, ma: MultiAff) -> UnionSet: ...

    def preimage_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> UnionSet: ...

    def preimage_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionSet: ...

    def project_out(self, type: dim_type, first: int, n: int) -> UnionSet: ...

    def project_out_all_params(self) -> UnionSet: ...

    def drop_unused_params(self) -> UnionSet: ...

    def remove_divs(self) -> UnionSet: ...

    def is_params(self) -> bool: ...

    def is_empty(self) -> bool: ...

    def is_subset(self, uset2: UnionSet | BasicSet | Set) -> bool: ...

    def is_equal(self, uset2: UnionSet | BasicSet | Set) -> bool: ...

    def is_disjoint(self, uset2: UnionSet | BasicSet | Set) -> bool: ...

    def is_strict_subset(self, uset2: UnionSet | BasicSet | Set) -> bool: ...

    def __hash__(self) -> int: ...

    def n_set(self) -> int: ...

    def foreach_set(self, fn: Callable[[Set], None]) -> None: ...

    def every_set(self, test: Callable[[Set], bool]) -> bool: ...

    def get_basic_set_list(self) -> BasicSetList: ...

    def get_set_list(self) -> SetList: ...

    def contains(self, space: Space) -> bool: ...

    def extract_set(self, space: Space) -> Set: ...

    def isa_set(self) -> bool: ...

    def as_set(self) -> Set: ...

    def foreach_point(self, fn: Callable[[Point], None]) -> None: ...

    def sample(self) -> BasicSet: ...

    def sample_point(self) -> Point: ...

    @staticmethod
    def from_point(pnt: Point) -> UnionSet: ...

    def lift(self) -> UnionSet: ...

    def lex_lt_union_set(self, uset2: UnionSet | BasicSet | Set) -> UnionMap: ...

    def lex_le_union_set(self, uset2: UnionSet | BasicSet | Set) -> UnionMap: ...

    def lex_gt_union_set(self, uset2: UnionSet | BasicSet | Set) -> UnionMap: ...

    def lex_ge_union_set(self, uset2: UnionSet | BasicSet | Set) -> UnionMap: ...

    def coefficients(self) -> UnionSet: ...

    def solutions(self) -> UnionSet: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> UnionSet: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    def to_list(self) -> UnionSetList: ...

    def compute_schedule(self, validity: UnionMap | BasicMap | Map, proximity: UnionMap | BasicMap | Map) -> Schedule: ...

    def min_multi_union_pw_aff(self, obj: MultiUnionPwAff) -> MultiVal: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class UnionMap:
    @overload
    def __init__(self, arg: Map, /) -> None: ...

    @overload
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    @staticmethod
    def from_union_pw_multi_aff(upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionMap: ...

    def as_union_pw_multi_aff(self) -> UnionPwMultiAff: ...

    @staticmethod
    def from_union_pw_aff(upa: UnionPwAff | Aff | PwAff) -> UnionMap: ...

    def as_multi_union_pw_aff(self) -> MultiUnionPwAff: ...

    @staticmethod
    def from_multi_union_pw_aff(mupa: MultiUnionPwAff) -> UnionMap: ...

    def apply_union_pw_qpolynomial_fold(self, upwf: UnionPwQPolynomialFold) -> tuple[UnionPwQPolynomialFold, bool]: ...

    def dim(self, type: dim_type) -> int: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def get_dim_id(self, type: dim_type, pos: int) -> Id: ...

    @staticmethod
    def from_basic_map(bmap: BasicMap) -> UnionMap: ...

    @staticmethod
    def from_map(map: Map | BasicMap) -> UnionMap: ...

    @staticmethod
    def empty_ctx(ctx: Context) -> UnionMap: ...

    @staticmethod
    def empty_space(space: Space) -> UnionMap: ...

    @staticmethod
    def empty(space: Space) -> UnionMap: ...

    def copy(self) -> UnionMap: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def reset_user(self) -> UnionMap: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def universe(self) -> UnionMap: ...

    def params(self) -> Set: ...

    def domain(self) -> UnionSet: ...

    def range(self) -> UnionSet: ...

    def domain_map(self) -> UnionMap: ...

    def domain_map_union_pw_multi_aff(self) -> UnionPwMultiAff: ...

    def range_map(self) -> UnionMap: ...

    @staticmethod
    def from_domain(uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    @staticmethod
    def from_range(uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def affine_hull(self) -> UnionMap: ...

    def polyhedral_hull(self) -> UnionMap: ...

    def remove_redundancies(self) -> UnionMap: ...

    def simple_hull(self) -> UnionMap: ...

    def coalesce(self) -> UnionMap: ...

    def compute_divs(self) -> UnionMap: ...

    def lexmin(self) -> UnionMap: ...

    def lexmax(self) -> UnionMap: ...

    def add_map(self, map: Map | BasicMap) -> UnionMap: ...

    def union(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def subtract(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def intersect(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def intersect_params(self, set: Set | BasicSet) -> UnionMap: ...

    def product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def domain_product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def flat_domain_product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def range_product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def flat_range_product(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def domain_factor_domain(self) -> UnionMap: ...

    def domain_factor_range(self) -> UnionMap: ...

    def range_factor_domain(self) -> UnionMap: ...

    def range_factor_range(self) -> UnionMap: ...

    def factor_domain(self) -> UnionMap: ...

    def factor_range(self) -> UnionMap: ...

    def gist(self, context: UnionMap | BasicMap | Map) -> UnionMap: ...

    def gist_params(self, set: Set | BasicSet) -> UnionMap: ...

    def gist_domain(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def gist_range(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def intersect_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def intersect_domain_space(self, space: Space) -> UnionMap: ...

    def intersect_domain(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def intersect_range_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def intersect_range_space(self, space: Space) -> UnionMap: ...

    def intersect_range(self, uset: UnionSet | BasicSet | Set) -> UnionMap: ...

    def intersect_domain_factor_domain(self, factor: UnionMap | BasicMap | Map) -> UnionMap: ...

    def intersect_domain_factor_range(self, factor: UnionMap | BasicMap | Map) -> UnionMap: ...

    def intersect_range_factor_domain(self, factor: UnionMap | BasicMap | Map) -> UnionMap: ...

    def intersect_range_factor_range(self, factor: UnionMap | BasicMap | Map) -> UnionMap: ...

    def intersect_domain_wrapped_domain_union_set(self, domain: UnionSet | BasicSet | Set) -> UnionMap: ...

    def intersect_range_wrapped_domain_union_set(self, domain: UnionSet | BasicSet | Set) -> UnionMap: ...

    def subtract_domain(self, dom: UnionSet | BasicSet | Set) -> UnionMap: ...

    def subtract_range(self, dom: UnionSet | BasicSet | Set) -> UnionMap: ...

    def apply_domain(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def apply_range(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def preimage_domain_multi_aff(self, ma: MultiAff) -> UnionMap: ...

    def preimage_range_multi_aff(self, ma: MultiAff) -> UnionMap: ...

    def preimage_domain_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> UnionMap: ...

    def preimage_range_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> UnionMap: ...

    def preimage_domain_multi_pw_aff(self, mpa: MultiPwAff) -> UnionMap: ...

    def preimage_domain_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionMap: ...

    def preimage_range_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> UnionMap: ...

    def reverse(self) -> UnionMap: ...

    def domain_reverse(self) -> UnionMap: ...

    def range_reverse(self) -> UnionMap: ...

    @staticmethod
    def from_domain_and_range(domain: UnionSet | BasicSet | Set, range: UnionSet | BasicSet | Set) -> UnionMap: ...

    def detect_equalities(self) -> UnionMap: ...

    def deltas(self) -> UnionSet: ...

    def deltas_map(self) -> UnionMap: ...

    def project_out_param_id(self, id: Id) -> UnionMap: ...

    def project_out_param_id_list(self, list: IdList) -> UnionMap: ...

    def project_out(self, type: dim_type, first: int, n: int) -> UnionMap: ...

    def project_out_all_params(self) -> UnionMap: ...

    def drop_unused_params(self) -> UnionMap: ...

    def remove_divs(self) -> UnionMap: ...

    def bind_range(self, tuple: MultiId) -> UnionSet: ...

    def plain_is_empty(self) -> bool: ...

    def is_empty(self) -> bool: ...

    def is_single_valued(self) -> bool: ...

    def plain_is_injective(self) -> bool: ...

    def is_injective(self) -> bool: ...

    def is_bijective(self) -> bool: ...

    def is_identity(self) -> bool: ...

    def is_subset(self, umap2: UnionMap | BasicMap | Map) -> bool: ...

    def is_equal(self, umap2: UnionMap | BasicMap | Map) -> bool: ...

    def is_disjoint(self, umap2: UnionMap | BasicMap | Map) -> bool: ...

    def is_strict_subset(self, umap2: UnionMap | BasicMap | Map) -> bool: ...

    def __hash__(self) -> int: ...

    def n_map(self) -> int: ...

    def foreach_map(self, fn: Callable[[Map], None]) -> None: ...

    def get_map_list(self) -> MapList: ...

    def every_map(self, test: Callable[[Map], bool]) -> bool: ...

    def remove_map_if(self, fn: Callable[[Map], bool]) -> UnionMap: ...

    def contains(self, space: Space) -> bool: ...

    def extract_map(self, space: Space) -> Map: ...

    def isa_map(self) -> bool: ...

    def as_map(self) -> Map: ...

    def sample(self) -> BasicMap: ...

    def fixed_power_val(self, exp: Val | int) -> UnionMap: ...

    def power(self) -> tuple[UnionMap, bool]: ...

    def transitive_closure(self) -> tuple[UnionMap, bool]: ...

    def lex_lt_union_map(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def lex_le_union_map(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def lex_gt_union_map(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def lex_ge_union_map(self, umap2: UnionMap | BasicMap | Map) -> UnionMap: ...

    def eq_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def lex_le_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def lex_lt_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def lex_ge_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    def lex_gt_at_multi_union_pw_aff(self, mupa: MultiUnionPwAff) -> UnionMap: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> UnionMap: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    def wrap(self) -> UnionSet: ...

    def zip(self) -> UnionMap: ...

    def curry(self) -> UnionMap: ...

    def range_curry(self) -> UnionMap: ...

    def uncurry(self) -> UnionMap: ...

    def align_params(self, model: Space) -> UnionMap: ...

    def to_list(self) -> UnionMapList: ...

    def compute_flow(self, must_source: UnionMap | BasicMap | Map, may_source: UnionMap | BasicMap | Map, schedule: UnionMap | BasicMap | Map) -> tuple[UnionMap, UnionMap, UnionMap, UnionMap]: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class Point:
    def to_set(self) -> Set: ...

    def get_ctx(self) -> Context: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    @staticmethod
    def zero(space: Space) -> Point: ...

    def copy(self) -> Point: ...

    def get_coordinate_val(self, type: dim_type, pos: int) -> Val: ...

    def set_coordinate_val(self, type: dim_type, pos: int, v: Val | int) -> Point: ...

    def get_multi_val(self) -> MultiVal: ...

    def add_ui(self, type: dim_type, pos: int, val: int) -> Point: ...

    def sub_ui(self, type: dim_type, pos: int, val: int) -> Point: ...

    @staticmethod
    def void(space: Space) -> Point: ...

    def is_void(self) -> bool: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class Vertex:
    def get_ctx(self) -> Context: ...

    def get_id(self) -> int: ...

    def get_domain(self) -> BasicSet: ...

    def get_expr(self) -> MultiAff: ...

class Cell:
    def get_ctx(self) -> Context: ...

    def get_domain(self) -> BasicSet: ...

    def foreach_vertex(self, fn: Callable[[Vertex], None]) -> None: ...

class Vertices:
    def get_ctx(self) -> Context: ...

    def get_n_vertices(self) -> int: ...

    def foreach_vertex(self, fn: Callable[[Vertex], None]) -> None: ...

    def foreach_cell(self, fn: Callable[[Cell], None]) -> None: ...

class StrideInfo:
    def get_ctx(self) -> Context: ...

    def get_stride(self) -> Val: ...

    def get_offset(self) -> Aff: ...

    def copy(self) -> StrideInfo: ...

class QPolynomial:
    def get_ctx(self) -> Context: ...

    def get_domain_space(self) -> Space: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def dim(self, type: dim_type) -> int: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def get_constant_val(self) -> Val: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> QPolynomial: ...

    @staticmethod
    def zero_on_domain(domain: Space) -> QPolynomial: ...

    @staticmethod
    def one_on_domain(domain: Space) -> QPolynomial: ...

    @staticmethod
    def infty_on_domain(domain: Space) -> QPolynomial: ...

    @staticmethod
    def neginfty_on_domain(domain: Space) -> QPolynomial: ...

    @staticmethod
    def nan_on_domain(domain: Space) -> QPolynomial: ...

    @staticmethod
    def val_on_domain(space: Space, val: Val | int) -> QPolynomial: ...

    @staticmethod
    def var_on_domain(domain: Space, type: dim_type, pos: int) -> QPolynomial: ...

    def copy(self) -> QPolynomial: ...

    def plain_is_equal(self, qp2: QPolynomial) -> bool: ...

    def is_zero(self) -> bool: ...

    def is_nan(self) -> bool: ...

    def is_infty(self) -> bool: ...

    def is_neginfty(self) -> bool: ...

    def sgn(self) -> int: ...

    def neg(self) -> QPolynomial: ...

    def add(self, qp2: QPolynomial) -> QPolynomial: ...

    def sub(self, qp2: QPolynomial) -> QPolynomial: ...

    def mul(self, qp2: QPolynomial) -> QPolynomial: ...

    def pow(self, power: int) -> QPolynomial: ...

    def scale_val(self, v: Val | int) -> QPolynomial: ...

    def scale_down_val(self, v: Val | int) -> QPolynomial: ...

    def domain_reverse(self) -> QPolynomial: ...

    def insert_dims(self, type: dim_type, first: int, n: int) -> QPolynomial: ...

    def add_dims(self, type: dim_type, n: int) -> QPolynomial: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> QPolynomial: ...

    def project_domain_on_params(self) -> QPolynomial: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> QPolynomial: ...

    def as_polynomial_on_domain(self, bset: BasicSet, fn: Callable[[BasicSet, QPolynomial], None]) -> None: ...

    def homogenize(self) -> QPolynomial: ...

    def align_params(self, model: Space) -> QPolynomial: ...

    def foreach_term(self, fn: Callable[[Term], None]) -> None: ...

    def eval(self, pnt: Point) -> Val: ...

    def gist_params(self, context: Set | BasicSet) -> QPolynomial: ...

    def gist(self, context: Set | BasicSet) -> QPolynomial: ...

    @staticmethod
    def from_constraint(c: Constraint, type: dim_type, pos: int) -> QPolynomial: ...

    @staticmethod
    def from_term(term: Term) -> QPolynomial: ...

    @staticmethod
    def from_aff(aff: Aff) -> QPolynomial: ...

    def isa_aff(self) -> bool: ...

    def as_aff(self) -> Aff: ...

    def dump(self) -> None: ...

    def to_list(self) -> QPolynomialList: ...

    get_terms = islpy._monkeypatch.qpolynomial_get_terms

    __add__ = islpy._monkeypatch.expr_like_add

    __radd__ = islpy._monkeypatch.expr_like_add

    __sub__ = islpy._monkeypatch.expr_like_sub

    __rsub__ = islpy._monkeypatch.expr_like_rsub

    __mul__ = islpy._monkeypatch.expr_like_mul

    __rmul__ = islpy._monkeypatch.expr_like_mul

    __neg__ = neg

    __pow__ = pow

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class PwQPolynomial:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    def involves_nan(self) -> bool: ...

    def plain_is_equal(self, pwqp2: PwQPolynomial) -> bool: ...

    @staticmethod
    def zero(space: Space) -> PwQPolynomial: ...

    @staticmethod
    def alloc(set: Set | BasicSet, qp: QPolynomial) -> PwQPolynomial: ...

    @staticmethod
    def from_qpolynomial(qp: QPolynomial) -> PwQPolynomial: ...

    def copy(self) -> PwQPolynomial: ...

    def is_zero(self) -> bool: ...

    def get_domain_space(self) -> Space: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def reset_domain_space(self, space: Space) -> PwQPolynomial: ...

    def dim(self, type: dim_type) -> int: ...

    def involves_param_id(self, id: Id) -> bool: ...

    def involves_dims(self, type: dim_type, first: int, n: int) -> bool: ...

    def has_equal_space(self, pwqp2: PwQPolynomial) -> bool: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> PwQPolynomial: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def reset_user(self) -> PwQPolynomial: ...

    def domain(self) -> Set: ...

    def intersect_domain(self, set: Set | BasicSet) -> PwQPolynomial: ...

    def intersect_domain_wrapped_domain(self, set: Set | BasicSet) -> PwQPolynomial: ...

    def intersect_domain_wrapped_range(self, set: Set | BasicSet) -> PwQPolynomial: ...

    def intersect_params(self, set: Set | BasicSet) -> PwQPolynomial: ...

    def subtract_domain(self, set: Set | BasicSet) -> PwQPolynomial: ...

    def project_domain_on_params(self) -> PwQPolynomial: ...

    def from_range(self) -> PwQPolynomial: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> PwQPolynomial: ...

    def split_dims(self, type: dim_type, first: int, n: int) -> PwQPolynomial: ...

    def drop_unused_params(self) -> PwQPolynomial: ...

    def add(self, pwqp2: PwQPolynomial) -> PwQPolynomial: ...

    def sub(self, pwqp2: PwQPolynomial) -> PwQPolynomial: ...

    def add_disjoint(self, pwqp2: PwQPolynomial) -> PwQPolynomial: ...

    def neg(self) -> PwQPolynomial: ...

    def mul(self, pwqp2: PwQPolynomial) -> PwQPolynomial: ...

    def scale_val(self, v: Val | int) -> PwQPolynomial: ...

    def scale_down_val(self, v: Val | int) -> PwQPolynomial: ...

    def pow(self, exponent: int) -> PwQPolynomial: ...

    def domain_reverse(self) -> PwQPolynomial: ...

    def insert_dims(self, type: dim_type, first: int, n: int) -> PwQPolynomial: ...

    def add_dims(self, type: dim_type, n: int) -> PwQPolynomial: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> PwQPolynomial: ...

    def fix_val(self, type: dim_type, n: int, v: Val | int) -> PwQPolynomial: ...

    def eval(self, pnt: Point) -> Val: ...

    def max(self) -> Val: ...

    def min(self) -> Val: ...

    def n_piece(self) -> int: ...

    def foreach_piece(self, fn: Callable[[Set, QPolynomial], None]) -> None: ...

    def every_piece(self, test: Callable[[Set, QPolynomial], bool]) -> bool: ...

    def foreach_lifted_piece(self, fn: Callable[[Set, QPolynomial], None]) -> None: ...

    def isa_qpolynomial(self) -> bool: ...

    def as_qpolynomial(self) -> QPolynomial: ...

    @staticmethod
    def from_pw_aff(pwaff: PwAff | Aff) -> PwQPolynomial: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> PwQPolynomial: ...

    def to_str(self) -> str: ...

    def dump(self) -> None: ...

    def coalesce(self) -> PwQPolynomial: ...

    def gist(self, context: Set | BasicSet) -> PwQPolynomial: ...

    def gist_params(self, context: Set | BasicSet) -> PwQPolynomial: ...

    def split_periods(self, max_periods: int) -> PwQPolynomial: ...

    def bound(self, type: fold) -> tuple[PwQPolynomialFold, bool]: ...

    def to_polynomial(self, sign: int) -> PwQPolynomial: ...

    def to_union_pw_qpolynomial(self) -> UnionPwQPolynomial: ...

    def to_list(self) -> PwQPolynomialList: ...

    get_pieces = islpy._monkeypatch.pwqpolynomial_get_pieces

    get_aggregate_domain = islpy._monkeypatch.pw_get_aggregate_domain

    eval_with_dict = islpy._monkeypatch.pwqpolynomial_eval_with_dict

    __add__ = islpy._monkeypatch.expr_like_add

    __radd__ = islpy._monkeypatch.expr_like_add

    __sub__ = islpy._monkeypatch.expr_like_sub

    __rsub__ = islpy._monkeypatch.expr_like_rsub

    __mul__ = islpy._monkeypatch.expr_like_mul

    __rmul__ = islpy._monkeypatch.expr_like_mul

    __neg__ = neg

    __pow__ = pow

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class QPolynomialFold:
    def get_ctx(self) -> Context: ...

    def get_type(self) -> int: ...

    @staticmethod
    def empty(type: fold, space: Space) -> QPolynomialFold: ...

    @staticmethod
    def alloc(type: fold, qp: QPolynomial) -> QPolynomialFold: ...

    def copy(self) -> QPolynomialFold: ...

    def is_empty(self) -> bool: ...

    def is_nan(self) -> bool: ...

    def plain_is_equal(self, fold2: QPolynomialFold) -> bool: ...

    def get_domain_space(self) -> Space: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def fold(self, fold2: QPolynomialFold) -> QPolynomialFold: ...

    def scale_val(self, v: Val | int) -> QPolynomialFold: ...

    def scale_down_val(self, v: Val | int) -> QPolynomialFold: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> QPolynomialFold: ...

    def eval(self, pnt: Point) -> Val: ...

    def gist_params(self, context: Set | BasicSet) -> QPolynomialFold: ...

    def gist(self, context: Set | BasicSet) -> QPolynomialFold: ...

    def foreach_qpolynomial(self, fn: Callable[[QPolynomial], None]) -> None: ...

    def dump(self) -> None: ...

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class PwQPolynomialFold:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def fix_val(self, type: dim_type, n: int, v: Val | int) -> PwQPolynomialFold: ...

    def get_ctx(self) -> Context: ...

    def get_type(self) -> int: ...

    def involves_nan(self) -> bool: ...

    def plain_is_equal(self, pwf2: PwQPolynomialFold) -> bool: ...

    @staticmethod
    def from_pw_qpolynomial(type: fold, pwqp: PwQPolynomial) -> PwQPolynomialFold: ...

    @staticmethod
    def alloc(type: fold, set: Set | BasicSet, fold: QPolynomialFold) -> PwQPolynomialFold: ...

    @staticmethod
    def from_qpolynomial_fold(fold: QPolynomialFold) -> PwQPolynomialFold: ...

    def copy(self) -> PwQPolynomialFold: ...

    def is_zero(self) -> bool: ...

    def get_domain_space(self) -> Space: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def reset_space(self, space: Space) -> PwQPolynomialFold: ...

    def dim(self, type: dim_type) -> int: ...

    def involves_param_id(self, id: Id) -> bool: ...

    def has_equal_space(self, pwf2: PwQPolynomialFold) -> bool: ...

    def __len__(self) -> int: ...

    @staticmethod
    def zero(space: Space, type: fold) -> PwQPolynomialFold: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> PwQPolynomialFold: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def reset_user(self) -> PwQPolynomialFold: ...

    def domain(self) -> Set: ...

    def intersect_domain(self, set: Set | BasicSet) -> PwQPolynomialFold: ...

    def intersect_domain_wrapped_domain(self, set: Set | BasicSet) -> PwQPolynomialFold: ...

    def intersect_domain_wrapped_range(self, set: Set | BasicSet) -> PwQPolynomialFold: ...

    def intersect_params(self, set: Set | BasicSet) -> PwQPolynomialFold: ...

    def subtract_domain(self, set: Set | BasicSet) -> PwQPolynomialFold: ...

    def add(self, pwf2: PwQPolynomialFold) -> PwQPolynomialFold: ...

    def fold(self, pwf2: PwQPolynomialFold) -> PwQPolynomialFold: ...

    def add_disjoint(self, pwf2: PwQPolynomialFold) -> PwQPolynomialFold: ...

    def scale_val(self, v: Val | int) -> PwQPolynomialFold: ...

    def scale_down_val(self, v: Val | int) -> PwQPolynomialFold: ...

    def project_domain_on_params(self) -> PwQPolynomialFold: ...

    def from_range(self) -> PwQPolynomialFold: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> PwQPolynomialFold: ...

    def move_dims(self, dst_type: dim_type, dst_pos: int, src_type: dim_type, src_pos: int, n: int) -> PwQPolynomialFold: ...

    def drop_unused_params(self) -> PwQPolynomialFold: ...

    def eval(self, pnt: Point) -> Val: ...

    def n_piece(self) -> int: ...

    def foreach_piece(self, fn: Callable[[Set, QPolynomialFold], None]) -> None: ...

    def every_piece(self, test: Callable[[Set, QPolynomialFold], bool]) -> bool: ...

    def foreach_lifted_piece(self, fn: Callable[[Set, QPolynomialFold], None]) -> None: ...

    def isa_qpolynomial_fold(self) -> bool: ...

    def as_qpolynomial_fold(self) -> QPolynomialFold: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> PwQPolynomialFold: ...

    def dump(self) -> None: ...

    def coalesce(self) -> PwQPolynomialFold: ...

    def gist(self, context: Set | BasicSet) -> PwQPolynomialFold: ...

    def gist_params(self, context: Set | BasicSet) -> PwQPolynomialFold: ...

    def max(self) -> Val: ...

    def min(self) -> Val: ...

    def bound(self) -> tuple[PwQPolynomialFold, bool]: ...

    def to_union_pw_qpolynomial_fold(self) -> UnionPwQPolynomialFold: ...

    def to_list(self) -> PwQPolynomialFoldList: ...

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class UnionPwQPolynomialFold:
    def get_ctx(self) -> Context: ...

    def dim(self, type: dim_type) -> int: ...

    def involves_nan(self) -> bool: ...

    def plain_is_equal(self, upwf2: UnionPwQPolynomialFold) -> bool: ...

    @staticmethod
    def from_pw_qpolynomial_fold(pwf: PwQPolynomialFold) -> UnionPwQPolynomialFold: ...

    @staticmethod
    def zero_ctx(ctx: Context, type: fold) -> UnionPwQPolynomialFold: ...

    @staticmethod
    def zero_space(space: Space, type: fold) -> UnionPwQPolynomialFold: ...

    @staticmethod
    def zero(space: Space, type: fold) -> UnionPwQPolynomialFold: ...

    def fold_pw_qpolynomial_fold(self, pwqp: PwQPolynomialFold) -> UnionPwQPolynomialFold: ...

    def copy(self) -> UnionPwQPolynomialFold: ...

    def fold(self, upwf2: UnionPwQPolynomialFold) -> UnionPwQPolynomialFold: ...

    def add_union_pw_qpolynomial(self, upwqp: UnionPwQPolynomial) -> UnionPwQPolynomialFold: ...

    def scale_val(self, v: Val | int) -> UnionPwQPolynomialFold: ...

    def scale_down_val(self, v: Val | int) -> UnionPwQPolynomialFold: ...

    def domain(self) -> UnionSet: ...

    def intersect_domain_space(self, space: Space) -> UnionPwQPolynomialFold: ...

    def intersect_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwQPolynomialFold: ...

    def intersect_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwQPolynomialFold: ...

    def intersect_domain_wrapped_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwQPolynomialFold: ...

    def intersect_domain_wrapped_range(self, uset: UnionSet | BasicSet | Set) -> UnionPwQPolynomialFold: ...

    def intersect_params(self, set: Set | BasicSet) -> UnionPwQPolynomialFold: ...

    def subtract_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwQPolynomialFold: ...

    def subtract_domain_space(self, space: Space) -> UnionPwQPolynomialFold: ...

    def subtract_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwQPolynomialFold: ...

    def get_type(self) -> int: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_pw_qpolynomial_fold_list(self) -> PwQPolynomialFoldList: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> UnionPwQPolynomialFold: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> UnionPwQPolynomialFold: ...

    def reset_user(self) -> UnionPwQPolynomialFold: ...

    def eval(self, pnt: Point) -> Val: ...

    def coalesce(self) -> UnionPwQPolynomialFold: ...

    def gist(self, context: UnionSet | BasicSet | Set) -> UnionPwQPolynomialFold: ...

    def gist_params(self, context: Set | BasicSet) -> UnionPwQPolynomialFold: ...

    def align_params(self, model: Space) -> UnionPwQPolynomialFold: ...

    def drop_unused_params(self) -> UnionPwQPolynomialFold: ...

    def n_pw_qpolynomial_fold(self) -> int: ...

    def foreach_pw_qpolynomial_fold(self, fn: Callable[[PwQPolynomialFold], None]) -> None: ...

    def every_pw_qpolynomial_fold(self, test: Callable[[PwQPolynomialFold], bool]) -> bool: ...

    def extract_pw_qpolynomial_fold(self, space: Space) -> PwQPolynomialFold: ...

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class UnionPwQPolynomial:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def get_ctx(self) -> Context: ...

    def dim(self, type: dim_type) -> int: ...

    def involves_nan(self) -> bool: ...

    def plain_is_equal(self, upwqp2: UnionPwQPolynomial) -> bool: ...

    @staticmethod
    def from_pw_qpolynomial(pwqp: PwQPolynomial) -> UnionPwQPolynomial: ...

    @staticmethod
    def zero_ctx(ctx: Context) -> UnionPwQPolynomial: ...

    @staticmethod
    def zero_space(space: Space) -> UnionPwQPolynomial: ...

    @staticmethod
    def zero(space: Space) -> UnionPwQPolynomial: ...

    def add_pw_qpolynomial(self, pwqp: PwQPolynomial) -> UnionPwQPolynomial: ...

    def copy(self) -> UnionPwQPolynomial: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> UnionPwQPolynomial: ...

    def to_str(self) -> str: ...

    def neg(self) -> UnionPwQPolynomial: ...

    def add(self, upwqp2: UnionPwQPolynomial) -> UnionPwQPolynomial: ...

    def sub(self, upwqp2: UnionPwQPolynomial) -> UnionPwQPolynomial: ...

    def mul(self, upwqp2: UnionPwQPolynomial) -> UnionPwQPolynomial: ...

    def scale_val(self, v: Val | int) -> UnionPwQPolynomial: ...

    def scale_down_val(self, v: Val | int) -> UnionPwQPolynomial: ...

    def domain(self) -> UnionSet: ...

    def intersect_domain_space(self, space: Space) -> UnionPwQPolynomial: ...

    def intersect_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwQPolynomial: ...

    def intersect_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwQPolynomial: ...

    def intersect_domain_wrapped_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwQPolynomial: ...

    def intersect_domain_wrapped_range(self, uset: UnionSet | BasicSet | Set) -> UnionPwQPolynomial: ...

    def intersect_params(self, set: Set | BasicSet) -> UnionPwQPolynomial: ...

    def subtract_domain_union_set(self, uset: UnionSet | BasicSet | Set) -> UnionPwQPolynomial: ...

    def subtract_domain_space(self, space: Space) -> UnionPwQPolynomial: ...

    def subtract_domain(self, uset: UnionSet | BasicSet | Set) -> UnionPwQPolynomial: ...

    def get_space(self) -> Space: ...

    @property
    def space(self) -> Space: ...

    def get_pw_qpolynomial_list(self) -> PwQPolynomialList: ...

    def set_dim_name(self, type: dim_type, pos: int, s: str) -> UnionPwQPolynomial: ...

    def find_dim_by_name(self, type: dim_type, name: str) -> int: ...

    def domain_reverse(self) -> UnionPwQPolynomial: ...

    def drop_dims(self, type: dim_type, first: int, n: int) -> UnionPwQPolynomial: ...

    def reset_user(self) -> UnionPwQPolynomial: ...

    def eval(self, pnt: Point) -> Val: ...

    def coalesce(self) -> UnionPwQPolynomial: ...

    def gist(self, context: UnionSet | BasicSet | Set) -> UnionPwQPolynomial: ...

    def gist_params(self, context: Set | BasicSet) -> UnionPwQPolynomial: ...

    def align_params(self, model: Space) -> UnionPwQPolynomial: ...

    def drop_unused_params(self) -> UnionPwQPolynomial: ...

    def n_pw_qpolynomial(self) -> int: ...

    def foreach_pw_qpolynomial(self, fn: Callable[[PwQPolynomial], None]) -> None: ...

    def every_pw_qpolynomial(self, test: Callable[[PwQPolynomial], bool]) -> bool: ...

    def extract_pw_qpolynomial(self, space: Space) -> PwQPolynomial: ...

    def bound(self, type: fold) -> tuple[UnionPwQPolynomialFold, bool]: ...

    def to_polynomial(self, sign: int) -> UnionPwQPolynomial: ...

    get_id_dict = islpy._monkeypatch.obj_get_id_dict

    get_var_dict = islpy._monkeypatch.obj_get_var_dict

    get_var_ids = islpy._monkeypatch.obj_get_var_ids

    get_var_names = islpy._monkeypatch.obj_get_var_names_via_space

    get_var_names_not_none = islpy._monkeypatch.obj_get_var_names_not_none_via_space

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class Term:
    def get_ctx(self) -> Context: ...

    def copy(self) -> Term: ...

    def dim(self, type: dim_type) -> int: ...

    def get_coefficient_val(self) -> Val: ...

    def get_exp(self, type: dim_type, pos: int) -> int: ...

    def get_div(self, pos: int) -> Aff: ...

class Schedule:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    @staticmethod
    def empty(space: Space) -> Schedule: ...

    @staticmethod
    def from_domain(domain: UnionSet | BasicSet | Set) -> Schedule: ...

    def copy(self) -> Schedule: ...

    def get_map(self) -> UnionMap: ...

    def get_ctx(self) -> Context: ...

    def plain_is_equal(self, schedule2: Schedule) -> bool: ...

    def get_root(self) -> ScheduleNode: ...

    def get_domain(self) -> UnionSet: ...

    def foreach_schedule_node_top_down(self, fn: Callable[[ScheduleNode], bool]) -> None: ...

    def map_schedule_node_bottom_up(self, fn: Callable[[ScheduleNode], ScheduleNode]) -> Schedule: ...

    def insert_context(self, context: Set | BasicSet) -> Schedule: ...

    def insert_partial_schedule(self, partial: MultiUnionPwAff) -> Schedule: ...

    def insert_guard(self, guard: Set | BasicSet) -> Schedule: ...

    def sequence(self, schedule2: Schedule) -> Schedule: ...

    def set(self, schedule2: Schedule) -> Schedule: ...

    def intersect_domain(self, domain: UnionSet | BasicSet | Set) -> Schedule: ...

    def gist_domain_params(self, context: Set | BasicSet) -> Schedule: ...

    def reset_user(self) -> Schedule: ...

    def align_params(self, space: Space) -> Schedule: ...

    def pullback_union_pw_multi_aff(self, upma: UnionPwMultiAff | MultiAff | PwMultiAff) -> Schedule: ...

    def expand(self, contraction: UnionPwMultiAff | MultiAff | PwMultiAff, expansion: Schedule) -> Schedule: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> Schedule: ...

    def dump(self) -> None: ...

    def to_str(self) -> str: ...

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class ScheduleConstraints:
    def __init__(self, s: str, context: Context | None = None) -> None: ...

    def copy(self) -> ScheduleConstraints: ...

    @staticmethod
    def on_domain(domain: UnionSet | BasicSet | Set) -> ScheduleConstraints: ...

    def set_context(self, context: Set | BasicSet) -> ScheduleConstraints: ...

    def set_validity(self, validity: UnionMap | BasicMap | Map) -> ScheduleConstraints: ...

    def set_coincidence(self, coincidence: UnionMap | BasicMap | Map) -> ScheduleConstraints: ...

    def set_proximity(self, proximity: UnionMap | BasicMap | Map) -> ScheduleConstraints: ...

    def set_conditional_validity(self, condition: UnionMap | BasicMap | Map, validity: UnionMap | BasicMap | Map) -> ScheduleConstraints: ...

    def get_ctx(self) -> Context: ...

    def get_domain(self) -> UnionSet: ...

    def get_context(self) -> Set: ...

    def get_validity(self) -> UnionMap: ...

    def get_coincidence(self) -> UnionMap: ...

    def get_proximity(self) -> UnionMap: ...

    def get_conditional_validity(self) -> UnionMap: ...

    def get_conditional_validity_condition(self) -> UnionMap: ...

    def apply(self, umap: UnionMap | BasicMap | Map) -> ScheduleConstraints: ...

    @staticmethod
    def read_from_str(ctx: Context, str: str) -> ScheduleConstraints: ...

    def dump(self) -> None: ...

    def to_str(self) -> str: ...

    def compute_schedule(self) -> Schedule: ...

    __reduce__ = islpy._monkeypatch.generic_reduce

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class ScheduleNode:
    @staticmethod
    def from_domain(domain: UnionSet | BasicSet | Set) -> ScheduleNode: ...

    @staticmethod
    def from_extension(extension: UnionMap | BasicMap | Map) -> ScheduleNode: ...

    def copy(self) -> ScheduleNode: ...

    def is_equal(self, node2: ScheduleNode) -> bool: ...

    def get_ctx(self) -> Context: ...

    def get_type(self) -> int: ...

    def get_parent_type(self) -> int: ...

    def get_schedule(self) -> Schedule: ...

    def foreach_descendant_top_down(self, fn: Callable[[ScheduleNode], bool]) -> None: ...

    def every_descendant(self, test: Callable[[ScheduleNode], bool]) -> bool: ...

    def foreach_ancestor_top_down(self, fn: Callable[[ScheduleNode], None]) -> None: ...

    def map_descendant_bottom_up(self, fn: Callable[[ScheduleNode], ScheduleNode]) -> ScheduleNode: ...

    def get_tree_depth(self) -> int: ...

    def has_parent(self) -> bool: ...

    def has_children(self) -> bool: ...

    def has_previous_sibling(self) -> bool: ...

    def has_next_sibling(self) -> bool: ...

    def n_children(self) -> int: ...

    def get_child_position(self) -> int: ...

    def get_ancestor_child_position(self, ancestor: ScheduleNode) -> int: ...

    def get_child(self, pos: int) -> ScheduleNode: ...

    def get_shared_ancestor(self, node2: ScheduleNode) -> ScheduleNode: ...

    def root(self) -> ScheduleNode: ...

    def parent(self) -> ScheduleNode: ...

    def grandparent(self) -> ScheduleNode: ...

    def ancestor(self, generation: int) -> ScheduleNode: ...

    def child(self, pos: int) -> ScheduleNode: ...

    def grandchild(self, pos1: int, pos2: int) -> ScheduleNode: ...

    def first_child(self) -> ScheduleNode: ...

    def previous_sibling(self) -> ScheduleNode: ...

    def next_sibling(self) -> ScheduleNode: ...

    def is_subtree_anchored(self) -> bool: ...

    def group(self, group_id: Id) -> ScheduleNode: ...

    def sequence_splice_child(self, pos: int) -> ScheduleNode: ...

    def sequence_splice_children(self) -> ScheduleNode: ...

    def band_get_space(self) -> Space: ...

    def band_get_partial_schedule(self) -> MultiUnionPwAff: ...

    def band_get_partial_schedule_union_map(self) -> UnionMap: ...

    def band_member_get_ast_loop_type(self, pos: int) -> int: ...

    def band_member_set_ast_loop_type(self, pos: int, type: ast_loop_type) -> ScheduleNode: ...

    def band_member_get_isolate_ast_loop_type(self, pos: int) -> int: ...

    def band_member_set_isolate_ast_loop_type(self, pos: int, type: ast_loop_type) -> ScheduleNode: ...

    def band_get_ast_build_options(self) -> UnionSet: ...

    def band_set_ast_build_options(self, options: UnionSet | BasicSet | Set) -> ScheduleNode: ...

    def band_get_ast_isolate_option(self) -> Set: ...

    def band_n_member(self) -> int: ...

    def band_member_get_coincident(self, pos: int) -> bool: ...

    def band_member_set_coincident(self, pos: int, coincident: int) -> ScheduleNode: ...

    def band_get_permutable(self) -> bool: ...

    def band_set_permutable(self, permutable: int) -> ScheduleNode: ...

    def band_scale(self, mv: MultiVal) -> ScheduleNode: ...

    def band_scale_down(self, mv: MultiVal) -> ScheduleNode: ...

    def band_mod(self, mv: MultiVal) -> ScheduleNode: ...

    def band_shift(self, shift: MultiUnionPwAff) -> ScheduleNode: ...

    def band_tile(self, sizes: MultiVal) -> ScheduleNode: ...

    def band_sink(self) -> ScheduleNode: ...

    def band_split(self, pos: int) -> ScheduleNode: ...

    def context_get_context(self) -> Set: ...

    def domain_get_domain(self) -> UnionSet: ...

    def expansion_get_expansion(self) -> UnionMap: ...

    def expansion_get_contraction(self) -> UnionPwMultiAff: ...

    def extension_get_extension(self) -> UnionMap: ...

    def filter_get_filter(self) -> UnionSet: ...

    def guard_get_guard(self) -> Set: ...

    def mark_get_id(self) -> Id: ...

    def get_schedule_depth(self) -> int: ...

    def get_domain(self) -> UnionSet: ...

    def get_universe_domain(self) -> UnionSet: ...

    def get_prefix_schedule_multi_union_pw_aff(self) -> MultiUnionPwAff: ...

    def get_prefix_schedule_union_pw_multi_aff(self) -> UnionPwMultiAff: ...

    def get_prefix_schedule_union_map(self) -> UnionMap: ...

    def get_prefix_schedule_relation(self) -> UnionMap: ...

    def get_subtree_schedule_union_map(self) -> UnionMap: ...

    def get_subtree_expansion(self) -> UnionMap: ...

    def get_subtree_contraction(self) -> UnionPwMultiAff: ...

    def insert_context(self, context: Set | BasicSet) -> ScheduleNode: ...

    def insert_partial_schedule(self, schedule: MultiUnionPwAff) -> ScheduleNode: ...

    def insert_filter(self, filter: UnionSet | BasicSet | Set) -> ScheduleNode: ...

    def insert_guard(self, context: Set | BasicSet) -> ScheduleNode: ...

    def insert_mark(self, mark: Id) -> ScheduleNode: ...

    def insert_sequence(self, filters: UnionSetList) -> ScheduleNode: ...

    def insert_set(self, filters: UnionSetList) -> ScheduleNode: ...

    def cut(self) -> ScheduleNode: ...

    def delete(self) -> ScheduleNode: ...

    def order_before(self, filter: UnionSet | BasicSet | Set) -> ScheduleNode: ...

    def order_after(self, filter: UnionSet | BasicSet | Set) -> ScheduleNode: ...

    def graft_before(self, graft: ScheduleNode) -> ScheduleNode: ...

    def graft_after(self, graft: ScheduleNode) -> ScheduleNode: ...

    def reset_user(self) -> ScheduleNode: ...

    def align_params(self, space: Space) -> ScheduleNode: ...

    def dump(self) -> None: ...

    def to_str(self) -> str: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class AccessInfo:
    def get_ctx(self) -> Context: ...

    def compute_flow(self) -> Flow: ...

class Flow:
    def get_no_source(self, must: int) -> Map: ...

    def get_ctx(self) -> Context: ...

class Restriction:
    @staticmethod
    def empty(source_map: Map | BasicMap) -> Restriction: ...

    @staticmethod
    def none(source_map: Map | BasicMap) -> Restriction: ...

    @staticmethod
    def input(source_restr: Set | BasicSet, sink_restr: Set | BasicSet) -> Restriction: ...

    @staticmethod
    def output(source_restr: Set | BasicSet) -> Restriction: ...

    def get_ctx(self) -> Context: ...

class UnionAccessInfo:
    @staticmethod
    def from_sink(sink: UnionMap | BasicMap | Map) -> UnionAccessInfo: ...

    def set_must_source(self, must_source: UnionMap | BasicMap | Map) -> UnionAccessInfo: ...

    def set_may_source(self, may_source: UnionMap | BasicMap | Map) -> UnionAccessInfo: ...

    def set_kill(self, kill: UnionMap | BasicMap | Map) -> UnionAccessInfo: ...

    def set_schedule(self, schedule: Schedule) -> UnionAccessInfo: ...

    def set_schedule_map(self, schedule_map: UnionMap | BasicMap | Map) -> UnionAccessInfo: ...

    def copy(self) -> UnionAccessInfo: ...

    def get_ctx(self) -> Context: ...

    def to_str(self) -> str: ...

    def compute_flow(self) -> UnionFlow: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class UnionFlow:
    def get_ctx(self) -> Context: ...

    def copy(self) -> UnionFlow: ...

    def get_must_dependence(self) -> UnionMap: ...

    def get_may_dependence(self) -> UnionMap: ...

    def get_full_must_dependence(self) -> UnionMap: ...

    def get_full_may_dependence(self) -> UnionMap: ...

    def get_must_no_source(self) -> UnionMap: ...

    def get_may_no_source(self) -> UnionMap: ...

    def to_str(self) -> str: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class AstExpr:
    @staticmethod
    def from_val(v: Val) -> AstExpr: ...

    @staticmethod
    def from_id(id: Id) -> AstExpr: ...

    def neg(self) -> AstExpr: ...

    def add(self, expr2: AstExpr) -> AstExpr: ...

    def sub(self, expr2: AstExpr) -> AstExpr: ...

    def mul(self, expr2: AstExpr) -> AstExpr: ...

    def div(self, expr2: AstExpr) -> AstExpr: ...

    def pdiv_q(self, expr2: AstExpr) -> AstExpr: ...

    def pdiv_r(self, expr2: AstExpr) -> AstExpr: ...

    def and_then(self, expr2: AstExpr) -> AstExpr: ...

    def or_else(self, expr2: AstExpr) -> AstExpr: ...

    def le(self, expr2: AstExpr) -> AstExpr: ...

    def lt(self, expr2: AstExpr) -> AstExpr: ...

    def ge(self, expr2: AstExpr) -> AstExpr: ...

    def gt(self, expr2: AstExpr) -> AstExpr: ...

    def eq(self, expr2: AstExpr) -> AstExpr: ...

    def access(self, indices: AstExprList) -> AstExpr: ...

    def call(self, arguments: AstExprList) -> AstExpr: ...

    def address_of(self) -> AstExpr: ...

    def copy(self) -> AstExpr: ...

    def get_ctx(self) -> Context: ...

    def get_type(self) -> int: ...

    def int_get_val(self) -> Val: ...

    def get_val(self) -> Val: ...

    def id_get_id(self) -> Id: ...

    def get_id(self) -> Id: ...

    def op_get_type(self) -> int: ...

    def get_op_type(self) -> int: ...

    def op_get_n_arg(self) -> int: ...

    def get_op_n_arg(self) -> int: ...

    def op_get_arg(self, pos: int) -> AstExpr: ...

    def get_op_arg(self, pos: int) -> AstExpr: ...

    def set_op_arg(self, pos: int, arg: AstExpr) -> AstExpr: ...

    def is_equal(self, expr2: AstExpr) -> bool: ...

    def substitute_ids(self, id2expr: IdToAstExpr) -> AstExpr: ...

    def dump(self) -> None: ...

    def to_str(self) -> str: ...

    def to_C_str(self) -> str: ...

    @staticmethod
    def op_type_set_print_name(p: Printer, type: ast_expr_op_type, name: str) -> Printer: ...

    def print_macros(self, p: Printer) -> Printer: ...

    def to_list(self) -> AstExprList: ...

    __eq__ = islpy._monkeypatch.obj_eq

    __ne__ = islpy._monkeypatch.obj_ne

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class AstNode:
    @staticmethod
    def user_from_expr(expr: AstExpr) -> AstNode: ...

    @staticmethod
    def alloc_user(expr: AstExpr) -> AstNode: ...

    def copy(self) -> AstNode: ...

    def get_ctx(self) -> Context: ...

    def get_type(self) -> int: ...

    def set_annotation(self, annotation: Id) -> AstNode: ...

    def get_annotation(self) -> Id: ...

    def for_get_iterator(self) -> AstExpr: ...

    def for_get_init(self) -> AstExpr: ...

    def for_get_cond(self) -> AstExpr: ...

    def for_get_inc(self) -> AstExpr: ...

    def for_get_body(self) -> AstNode: ...

    def for_is_degenerate(self) -> bool: ...

    def if_get_cond(self) -> AstExpr: ...

    def if_get_then_node(self) -> AstNode: ...

    def if_get_then(self) -> AstNode: ...

    def if_has_else_node(self) -> bool: ...

    def if_has_else(self) -> bool: ...

    def if_get_else_node(self) -> AstNode: ...

    def if_get_else(self) -> AstNode: ...

    def block_get_children(self) -> AstNodeList: ...

    def mark_get_id(self) -> Id: ...

    def mark_get_node(self) -> AstNode: ...

    def user_get_expr(self) -> AstExpr: ...

    def foreach_descendant_top_down(self, fn: Callable[[AstNode], bool]) -> None: ...

    def map_descendant_bottom_up(self, fn: Callable[[AstNode], AstNode]) -> AstNode: ...

    def dump(self) -> None: ...

    def to_str(self) -> str: ...

    def print_macros(self, p: Printer) -> Printer: ...

    def for_print(self, p: Printer, options: AstPrintOptions) -> Printer: ...

    def if_print(self, p: Printer, options: AstPrintOptions) -> Printer: ...

    def to_C_str(self) -> str: ...

    def to_list(self) -> AstNodeList: ...

    __str__ = islpy._monkeypatch.generic_str

    __repr__ = islpy._monkeypatch.generic_repr

class AstBuild:
    def get_ctx(self) -> Context: ...

    @staticmethod
    def alloc(ctx: Context) -> AstBuild: ...

    @staticmethod
    def from_context(set: Set | BasicSet) -> AstBuild: ...

    def get_schedule_space(self) -> Space: ...

    def get_schedule(self) -> UnionMap: ...

    def restrict(self, set: Set | BasicSet) -> AstBuild: ...

    def copy(self) -> AstBuild: ...

    def set_options(self, options: UnionMap | BasicMap | Map) -> AstBuild: ...

    def set_iterators(self, iterators: IdList) -> AstBuild: ...

    def set_at_each_domain(self, fn: Callable[[AstNode, AstBuild], AstNode]) -> tuple[AstBuild, CallbackLifetimeHandle ]: ...

    def set_before_each_for(self, fn: Callable[[AstBuild], Id]) -> tuple[AstBuild, CallbackLifetimeHandle ]: ...

    def set_after_each_for(self, fn: Callable[[AstNode, AstBuild], AstNode]) -> tuple[AstBuild, CallbackLifetimeHandle ]: ...

    def set_before_each_mark(self, fn: Callable[[Id, AstBuild], None]) -> tuple[AstBuild, CallbackLifetimeHandle ]: ...

    def set_after_each_mark(self, fn: Callable[[AstNode, AstBuild], AstNode]) -> tuple[AstBuild, CallbackLifetimeHandle ]: ...

    def set_create_leaf(self, fn: Callable[[AstBuild], AstNode]) -> tuple[AstBuild, CallbackLifetimeHandle ]: ...

    def expr_from_set(self, set: Set | BasicSet) -> AstExpr: ...

    def expr_from_pw_aff(self, pa: PwAff | Aff) -> AstExpr: ...

    def access_from_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> AstExpr: ...

    def access_from_multi_pw_aff(self, mpa: MultiPwAff) -> AstExpr: ...

    def call_from_pw_multi_aff(self, pma: PwMultiAff | MultiAff) -> AstExpr: ...

    def call_from_multi_pw_aff(self, mpa: MultiPwAff) -> AstExpr: ...

    def node_from_schedule(self, schedule: Schedule) -> AstNode: ...

    def node_from_schedule_map(self, schedule: UnionMap | BasicMap | Map) -> AstNode: ...

    def ast_from_schedule(self, schedule: UnionMap | BasicMap | Map) -> AstNode: ...

class AstPrintOptions:
    @staticmethod
    def alloc(ctx: Context) -> AstPrintOptions: ...

    def copy(self) -> AstPrintOptions: ...

    def get_ctx(self) -> Context: ...

    def set_print_user(self, print_user: Callable[[Printer, AstPrintOptions, AstNode], Printer]) -> tuple[AstPrintOptions, CallbackLifetimeHandle ]: ...

    def set_print_for(self, print_for: Callable[[Printer, AstPrintOptions, AstNode], Printer]) -> tuple[AstPrintOptions, CallbackLifetimeHandle ]: ...
